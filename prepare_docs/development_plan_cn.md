# AI 集成仓库模板 – 开发计划

本文档概述了构建 AI 集成仓库模板的综合开发计划，分为多个连续阶段。每个阶段描述了目标、范围、原理和预期成果。该计划整合了初始需求和后续的设计修改，确保涵盖所有关键机制、约定和原则（优先考虑修改后的规范，在存在差异时以修改后的规范为准）。

## Phase 1：仓库文档标准与设置

**目标**：建立稳健的文档框架，作为 AI 友好仓库的基础。这包括标准化文档格式、命名约定、目录结构，并确保文档针对 AI 消费进行了优化。

**范围**：在此阶段，我们将在整个仓库中设置核心文档约定。主要任务包括：

- **定义文档角色和受众**：所有文档必须清楚地标明是面向 AI 还是面向人类读者（在前置元数据中），并遵守特定角色的指导原则。面向 AI 的文档（如路由指南、代理策略、能力索引等）应保持简洁（通常 <150 行）且高度结构化，而面向人类的文档（例如 README）没有严格的长度限制，但应标明 AI 可以忽略它们。
- **执行格式和样式规则**：所有文档使用 UTF-8 编码和 Markdown 格式。所有内容生成和编辑（除非用户特别要求）应为英文。避免非结构化散文或过度使用表情符号/符号（简单的状态图标除外）。
- **建立文件、目录和代码的命名约定**：例如，文档文件使用 kebab-case（例如 data-spec.md），环境常量使用 UPPER_SNAKE_CASE，Python 变量/函数使用 camelCase，类使用 PascalCase，数据库实体使用 snake_case。标准命名模式可防止混淆和冲突（例如，使用 <topic>-<type> 或 <topic>.<type> 后缀以提高清晰度）。
- **组织文档目录**：所有面向 AI 的文档将位于专用路径下，如 doc_agent/（用于 AI 特定知识）或模块特定的 doc/ 子文件夹中，而面向人类的文档（除高级 README 外）将位于 doc_human/ 下或明确分离，以避免混合上下文。进行中的上下文笔记将位于 ai/workdocs/（包含 active 和 archive 子文件夹）中，内部报告位于 ai/reports/，确保 AI 不会意外加载无关的人类导向或归档内容。
- **为所有 AI 可读文档准备前置元数据模式**：每个此类文件必须以标准化的 YAML 前置元数据开头，声明字段如 audience（必须是 "ai" 或 "human"，不能两者兼有）、purpose、doc_role（例如 quickstart、guide、spec、contract 等）、doc_kind（例如 router、agent_policy、capability_index 等），以及元数据如 updated_at 和所有权标签。叶节点文档（路由指向的最终内容文档）应在前置元数据中包含 route_role: leaf，以标记它们为文档路由树中的端点。我们还将引入模式文件（例如 spec/front-matter.schema.yaml 等）来定义这些前置元数据结构，并启用文档格式验证。
- **在文档设计中实现"渐进式披露"原则**：顶级 AI 入口文档（如 ROUTING.md）将保持极其轻量——仅列出基本角色、导航链接或常用命令，没有冗长的背景文本。更深入的详细信息被推迟到较低级别的指南或规范中，通过链接引用，因此 AI 只读取当前任务所需的内容。高级文档回答"做什么，在哪里找到它"；中级文档作为特定任务的手册或策略；低级文档提供完整的技术细节或示例。这种结构帮助 AI 最初加载最少的内容，然后根据需要逐步获取更详细的文档（避免令牌溢出）。我们将把这种渐进式加载方法编入文档编写的最佳实践（例如，在文档中添加关于下一步应阅读哪个文档或部分以获得更深入信息的注释）。
- **确定要在仓库根目录和模块中存在的核心文档文件**：按照约定，每个作为导航中心的目录将包含一个 ROUTING.md（用于导航），如果该目录包含 AI 可执行组件，则可能包含一个 ABILITY.md（原名 CAPABILITIES.md，用于能力索引）和一个 AGENTS.md（用于本地代理策略）。但是，根据修订后的共识，仓库的根目录将保存主要的 AGENTS.md，作为整个项目的单一全局策略和防护栏入口（整合全局规则）。模块目录如果有自己的执行逻辑，可以有自己的 AGENTS.md，但要求在每个子目录中都有所有三个文件的要求已放宽，以减少冗余。如果目录纯粹用于文档或不托管活动代理，它可以省略本地 AGENTS.md 或 ABILITY.md，更高级别的路由将简单地链接到该模块中的相关文档。

**原理**：一致的文档标准至关重要，因为仓库的"AI 友好性"取决于 AI 代理导航和理解文档的能力。明确区分人类与 AI 文档可防止 AI 阅读无关或冗长的材料。结构化的前置元数据和规范的格式确保 AI 能够可靠地解析文档，以确认它正在为其上下文阅读正确的文件。渐进式披露通过引导 AI 仅在需要时加载少量相关文档片段，解决了上下文窗口限制的问题。严格的命名和放置约定减少了歧义并支持文档的自动索引。总体而言，这些标准通过提供可预测的知识环境，为 AI 高效、安全地执行检索、规划和编码任务奠定了基础。

**预期成果**：到 Phase 1 结束时，仓库将包含定义良好的文档层次结构和样式指南。所有初始文档文件（全局 README、根目录和任何核心子目录中的 ROUTING.md、全局 AGENTS.md、全局 ABILITY.md 等）将使用适当的前置元数据和内容结构创建，作为未来文档的模板。我们将在可见的位置（可能是 doc_human/CONTRIBUTING.md 或类似文件）记录命名约定和格式规则。将设置工具或 linter 来验证这些约定（例如检查前置元数据的存在、行数限制、命名模式）作为 CI 的一部分。这为所有后续开发阶段提供了坚实的基础。此阶段的文档质量是一个可交付成果：所有面向 AI 的文档都应通过"文档 lint"检查（确保没有断开的链接、正确的前置元数据以及遵守结构模式），并且文档路由图（将在 Phase 2 中构建）将识别所有这些文档。

## Phase 2：文档路由系统实现

**目标**：构建多级文档路由系统，高效地将 AI 引导至相关信息。该系统将使用分层 ROUTING.md 文件将高级上下文映射到特定主题和情况，确保 AI 知道对于任何给定的查询或任务应该"去哪里查找"。

**范围**：在 Phase 2 中，我们创建跨越整个仓库及其模块的路由结构。主要活动和组件包括：

- **为每个相关目录级别设计 ROUTING.md 文件**：每个 ROUTING.md 将包含一个结构化的 context_routes 条目列表，通常采用三层格式：scope → topic → when（一个分层指南，按高级领域、特定主题，然后是上下文条件进行过滤）。对于每个组合，路由条目将指定 target_docs——AI 应在该情况下加载的实际文档链接。这类似于图书馆索引：告诉 AI 应该查阅图书馆的哪个"部分"和哪本"书"以实现其当前目标。
- **确保覆盖所有知识领域**：根 ROUTING.md 将列出主要范围（例如"文档与标准"、"执行 – 数据库"、"执行 – API"、"模块指南"等），向下映射到模块特定或主题特定的 ROUTING.md 文件或文档。模块级 ROUTING.md 文件（如果存在）将进一步路由到该模块的内部（或直接路由到该模块的叶文档，如果模块很简单）。每个与 AI 相关的文档必须通过某些 ROUTING.md 引用路径可访问（这将通过文档映射审计进行验证）。
- **集成项目特定或需求特定的文档**：在设计评审期间建立的新规则是，任何重要的项目特定需求或背景文档都必须转换为 AI 可读的形式并接入路由树。我们将识别是否存在此类文档（例如设计规范、用户提供的需求文档），并确保它们作为叶节点或链接指南出现在路由系统中。这保证 AI 不会忽视自定义项目细节——基本上将"需求 → 文档 → 路由"视为 AI 感知的强制性链条。
- **澄清路由的注册范围**：我们确认只有路由文件本身及其直接叶节点在 context_routes 索引中明确列出。我们不会尝试注册每个子节或示例文件——叶文档内的子节应由 AI 根据需要逐步发现，而不是在路由中枚举（以避免索引过载）。面向人类的文档完全保留在路由索引之外。这种方法使路由表保持专注和可维护。
- **实现路由前置元数据和元数据**：每个 ROUTING.md 将包含一个前置元数据（带有 doc_kind: router、audience 等）和标准化结构。内容可能是将 scope/topic/when 映射到 target_docs 的表格或列表。我们还将维护一个中央 YAML 文件（例如 doc_agent/orchestration/doc-node-map.yaml），作为所有文档节点及其角色的权威注册表。此映射将帮助自动化工具验证路由文件和实际文档之间的一致性。
- **遵守分层路由责任**：顶级 ROUTING.md 专注于广泛的"读什么/去哪里"方向，而较低级别的可能包含更多特定上下文的说明或链接到快速入门和指南。我们避免在多个级别重复内容；每个 ROUTING.md 仅指向下一级别或最终文档，而不是重复这些文档的细节。这使每个路由文件保持简洁，整体导航清晰。
- **为核心主题创建初始路由条目**：例如，根 ROUTING.md 可能有一个条目，如 Scope: "文档与标准" – Topic: "仓库约定" – When: "设置或更新文档"，指向文档指南或标准（可能在 doc_agent/guide/ 目录中）。另一个例子：Scope: "执行 – 数据库" – Topic: "模式更改" – When: "修改数据库模式或迁移"指向 DB 子系统的文档（如 DB 规范或迁移指南）。同样，执行 – API 条目将路由到 API 网关和合同文档。我们将根据后续阶段开发的内容填充这些路由（Phase 6 用于 DB，Phase 7 用于 API 等），但占位符和结构将在现在建立。
- **设置管理路由的工具**：我们计划实现或配置脚本来验证和刷新路由索引。例如，doc_node_map_sync 脚本可以解析所有 ROUTING.md 文件以构建 doc-node-map.yaml，反之亦然，确保没有死链接或孤立文档。将引入 make route_lint 命令来捕获错误，如缺失的路由目标或引用文档中不一致的前置元数据。

**原理**：路由系统是使我们的 AI 编排器能够获取正确上下文的主干。没有它，AI 可能会浪费时间搜索或加载不相关的文档。通过系统地将上下文映射到文档，我们提高了任务规划的效率和可靠性——AI 将获得明确的指导，知道在哪里检索任何给定子任务的说明或参考资料。结构化的 scope-topic-when 格式还编码了关于何时某些文档相关的机构知识，帮助 AI 做出更好的规划决策（基本上将 AI 提示策略的一部分编码到文件系统中）。我们集成的修改（如在路由中包含项目特定信息）进一步确保将此模板定制到特定项目不会导致任何 AI 可访问的知识差距。维护权威的文档映射并使用自动化进行一致性检查，防止在更新路由时出现人为错误——这对于系统的增长和演进至关重要。

**预期成果**：到 Phase 2 结束时，每个相关目录（如果需要）将包含一个格式正确的 ROUTING.md，整个仓库的文档图将连接起来。我们期望能够执行测试，例如：从根 ROUTING.md 开始，AI 应该在几次跳转内到达任何相关的文档片段（目标通常是从根到找到所需叶节点不超过 2 次跳转）。文档节点映射和注册表将是最新的，列出所有路由条目及其目标文档，没有不匹配。验收标准包括路由中零断开的链接或缺失的引用（通过 route_lint 验证），以及每个引用的叶文档都使用匹配的前置元数据和目的进行正确标记。此阶段为后续阶段（特别是引入能力和模块的阶段）奠定了导航基础。

---

## Phase 3：能力编排图与能力索引

**目标**：开发能力编排系统，包括定义代理图（或功能路由图）和能力索引。该系统表示仓库的功能"能力"（低级方法和更高级的 AI 驱动工作流）以及它们如何编排在一起。本质上，我们正在构建 AI 的工具箱和工具如何组合的映射。

**范围**：Phase 3 涉及创建用于表示原子能力和编排过程的数据结构和文档：

- **建立两层能力模型**：我们采用两层功能节点的设计：
  - **低级能力**：细粒度的、通常是特定于实现的操作。这些包括仓库内部脚本、外部服务调用（到模型提供者或 API）、数据库操作等。我们按类型对低级节点进行分类，例如 script（内部脚本）、mcp（外部微服务或云提供者调用）、api（外部 API 调用）。低级能力旨在成为可互换的构建块。
  - **高级能力**：粗粒度的"能力"，这些是编排的工作流或代理，结合了多个步骤或决策。通常有两种类型：workflow（确定性管道或序列，通常按顺序调用多个脚本）和 agent（AI 驱动的决策过程，可以动态调用各种低级方法）。高级节点表示编排器将调度和管理的任务；这些作为编排器的实际可执行单元出现，而低级方法在这些高级过程内部调用。
- **实现能力注册表**：我们将维护两个基于 YAML 的注册表文件来列出和定义这些节点：
  - **低级能力的方法注册表**（建议文件：doc_agent/orchestration/method_registry.yaml）。每个条目包含一个唯一 ID，格式为 base.<domain>.<action>（例如，base.db.migrate 用于数据库迁移脚本）。条目将详细说明如何执行它，例如，如果类型是 script，提供脚本路径和函数；如果类型是 mcp，提供目标服务和操作；如果类型是 api，提供外部 API 端点或密钥等。我们还列出输入/输出模式引用、所有者（负责的维护者或模块）以及用于搜索的标签。
  - **高级能力的能力注册表**（建议文件：doc_agent/orchestration/ability_registry.yaml）。每个条目有一个格式为 able.<domain>.<intent> 的 ID（例如，able.db.apply_all_migrations 用于应用迁移的工作流，或 able.repo.maintenance_assistant 用于帮助仓库维护的代理）。字段包括 tier（high）、kind（workflow 或 agent），以及详细信息，如步骤（对于工作流，要调用的低级 ID 序列，包含依赖关系）或它可以调用的能力（对于代理类型，它可能调用的低级 ID 白名单）。条目还将有一个 owner_module（链接到负责的模块）以及可能的 domain 和 intent 字段以澄清目的。
- **重命名能力索引文档**：根据修订后的标准，我们将使用 ABILITY.md 作为能力索引文档的名称（替换旧术语 CAPABILITIES.md）。每个公开能力的目录或模块将有一个 ABILITY.md，总结该范围内可用的能力（可能还有关键的低级方法）。全局仓库 ABILITY.md 将作为编排器可访问的高级能力的规范索引（整个仓库的"能力索引"）。它将标记为 doc_kind: capability_index（或者如果我们对齐命名，可能是 ability_index），并限制为约 250 行以保持简洁。此文档将列出能力节点及其描述/ID，可能按领域或模块分组，这有助于 AI 发现能力。
- **定义所有者和公开属性**：我们将确保每个能力条目包含一个 owner_id 或 owner_module 字段，将其绑定到模块或领域所有者。对于高级能力，只有一个模块可以拥有给定的能力——该模块是能力实现所在的地方，其本地策略适用。我们还为能力引入公开级别（例如 public vs internal）。公共能力是那些表示业务级操作或端点，旨在直接编排（用于跨模块或外部使用的入口点），而内部能力更像是子例程或"库"函数，旨在供其他能力重用，但不作为独立任务调用。这种区别指导文档（例如，我们可能只在某些摘要表中列出公共的）和编排器行为（编排器将主要为顶级任务调度公共能力，而内部能力仅作为依赖出现）。
- **将触发器与防护栏与图集成**：能力模型将扩展为链接到我们的自动化触发器系统（将在 Phase 8 中完全开发，但在此处概念上准备）。我们在能力条目上添加 safety_profile，以引用与该能力相关的任何触发器或防护栏 ID。例如，像 func.db.apply_all_migrations 这样的能力可以列出它与触发器 db-migration 和防护栏策略 require_approval_for_prod 相关联，总体风险级别为 high。相反，在触发器定义中，我们将包含一个 target 字段，指向相关的能力 ID。这种双向链接确保可追溯性：如果某个能力是高风险，我们可以快速找到保护它的触发器/批准，如果触发器触发，系统知道它正在保护哪个能力（或模块）。尽管触发器和防护栏将在稍后完全实现，我们现在将定义这些链接的数据模式，并在注册表中包含几个初始示例用于测试。
- **设置注册规则和成熟度级别**：为了防止能力集不受控制的增长，我们引入了添加新能力的治理：
  - **低级（方法）注册**：低级方法相对不受约束——任何需要的脚本或调用都可以添加到方法注册表中。但是，不允许注册临时或临时脚本。所有方法必须旨在作为可重用或永久能力（临时的一次性脚本应保留在 temp 目录中，不在注册表中）。
  - **高级（能力）注册**：我们为高级能力实现一个成熟度字段。新能力可以从 candidate 开始（意味着它们是实验性的或正在开发中）。候选能力可供 AI 和开发人员查看，并可能在测试中使用，但它们不会包含在官方能力索引中，也不会在生产中主动编排。一旦能力得到验证（例如，至少有 2 个测试用例、文档、稳定的接口），它可以标记为 stable。只有稳定的能力才能完全集成：它们出现在 ABILITY.md 中，并由编排器考虑用于实时任务执行。我们的 CI 管道将执行此规则：如果能力不稳定，它不应列在正式索引中或在生产工作流中调用。编排器在规划时将过滤掉非稳定能力。这提供了一个安全网：实验性功能在被验证之前不会意外触发关键操作。
- **开发能力注册工具**：为了简化添加新能力，我们计划构建交互式脚本。例如，register_lowtier.py 脚本指导开发人员（或 AI）添加新的低级方法条目。它将提示所有必填字段（强制要求没有缺失），并根据类型进行验证（例如，如果类型是 script，确保提供了脚本路径和入口点函数；如果类型是 api，需要 API 端点和凭据等）。它还将运行 lint（例如检查重复的 ID 或断开的引用）。类似地，我们可能会为高级节点创建 register_ability.py，包括将初始成熟度设置为 candidate 并确保存在所有者和至少一个存根文档/策略的逻辑。这些工具通过将所有更改通过受控路径进行，有助于维护单一事实来源原则。

**原理**：编排图是 AI 集成的核心：它形式化了 AI 可以做什么（能力）以及复杂任务如何组合（能力）。通过分离低级和高级，我们实现了模块化——低级方法可以交换或重用，高级工作流封装业务逻辑。这防止编排器被细节淹没（它只"看到"高级图），并简化了策略执行（防护栏主要附加到高级能力，而不是每个原子操作）。命名约定（base.* vs able.*）和层级字段明确编码了这种分离，减少了歧义。引入成熟度级别对于安全的 AI 协同开发至关重要：它为新能力创建了一个暂存区，确保只有经过验证的函数成为核心执行集的一部分。注册表工具和模式验证旨在缓解在复杂的引用网络（ID、依赖、触发器、所有者等）中可能出现的错误。在设计讨论期间，团队确定管理不善这些关系可能导致编排错误或安全漏洞，因此强调统一配置模式和这些关系的自动化。严格的注册表还意味着 AI 和开发人员可以查询单一来源（YAML 或 ABILITY.md）以发现可用能力及其用法，提高透明度和重用性。

**预期成果**：到 Phase 3 结束时，我们将拥有：

- 方法注册表和能力注册表 YAML 文件已就位，每个都填充了初始条目，涵盖模板开箱即用的基本操作和工作流（例如运行测试、应用 DB 迁移、生成文档等方法，以及设置新模块、执行维护任务等能力）。这些条目将包含 owner、kind 等字段，如所述，并遵循新的命名方案。
- 一个全局 ABILITY.md，记录高级能力（带有简要描述和对它们的注册表定义或文档的引用）。为了一致性，它将反映 YAML 内容（我们可能从注册表自动生成其中的部分）。此文档将验证行数和完整性。
- 在数据模型中初步集成触发器/防护栏（即使实际的触发器处理逻辑稍后出现）。我们将确认，对于一个示例风险能力（如数据库模式迁移），YAML 中的能力条目有一个链接到触发器 ID 的 safety_profile，并且相应的触发器条目（将在 Phase 8 中定义）可以指回该能力。这种往返链接将通过我们的一致性脚本进行测试。
- 代理（或编排器）图模型已构建。我们可能有一个文件 agent-graph.yaml，表示高级节点的有向图以及它们如何连接（这可能从能力注册表派生，特别是对于通过 depends_on 定义边的工作流）。至少，所有高级能力及其关系（调用或步骤）将清晰并记录在案。将引入像 agent_graph_check.py 这样的工具来验证此图结构（例如，除非明确允许，否则没有循环，所有依赖节点都存在等）。
- 所有这些都应通过初始能力 lint：运行 make capability_index_check 和 scripts/registry_check.py 以确保我们的 ABILITY.md、注册表 YAML 和代理图保持同步。这作为未来更改的基线。能力索引和图将准备好集成来自后续阶段的领域特定能力。

---

## Phase 4：全局和本地代理策略文档（AGENTS.md）

**目标**：定义并实现代理策略文档，规定 AI（代码模型）被允许和预期做什么。这包括全局策略（根 AGENTS.md）、策略的聚合索引（doc_agent/AGENTS.md）和模块特定的策略文件，每个都概述了 AI 在该上下文中工作时的规则、防护栏和重要流程。

**范围**：在 Phase 4 中，我们专注于 AGENTS.md 文件的内容和结构：

- **创建全局代理策略（根 AGENTS.md）**：这是整个仓库的顶级策略文档。它将在前置元数据中携带 audience: ai 和 doc_kind: agent_policy，并作为 AI 理解全局规则的第一站。要包含的关键元素：
  - **全局防护栏和范围**：明确 AI 在全局范围内可以做和不能做的定义。例如，列出禁止的操作（例如"不要直接修改生产配置"）、某些操作所需的批准、环境限制等。这为 AI 贡献设置了边界条件。
  - **执行前要求**：诸如"所有更改必须在提交前通过测试和 lint"或"文档更新必须伴随代码更改"等策略可以在此处作为强制性步骤说明（AI 将被指示在完成任务之前始终遵循这些步骤）。
  - **AI 阅读清单（必读文档）**：提供 AI 应至少完整阅读一次的基本文档的精选列表。例如：文档路由原则和渐进式阅读规则（以便 AI 了解如何导航文档）、workdocs 和上下文恢复使用的说明，以及触发器/防护栏机制的概述。这些对于使 AI 与仓库的工作模式保持一致至关重要，基本上是引导 AI 了解如何在我们系统内工作。
  - **条件阅读清单（可选）**：列出 AI 在相关时应加载的其他指南。例如，解释何时以及如何运行测试的测试规则指南、详细说明如何构建拉取请求的 PR 规则指南（提交消息约定、分支命名等）以及任何提交/分支约定摘要。全局策略可以指示："准备 PR 时，阅读 pr-rules 部分"和"准备运行测试时，参考 test-rules"等（我们将确保此类指南存在于文档中）。
  - **路由入口点**：全局策略应明确指出 AI 可以找到路由索引的位置。例如，"使用仓库根目录的 ROUTING.md 作为文档查找的规范起点，使用 ABILITY.md 获取功能能力列表"。这帮助 AI 快速定位自己以查找信息或工具。
  - **Workdocs 使用**：澄清围绕 workdocs 的期望（例如"在任务执行期间，始终在 ai/workdocs/active/plan.md 或 context.md 中记录您的计划和关键决策，并遵循上下文恢复指南以恢复任务"）。还提及如何以及何时归档或总结（尽管自动化将处理此问题，AI 应了解该过程）。
  - **触发器/批准基础知识**：概述触发器和防护栏的存在、它们的基本优先级级别以及如果某些内容被阻止意味着什么，以及 AI 应如何反应（例如，如果触发器需要人工批准，AI 应暂停并在 workdoc 中请求它等）。这使 AI 准备好与安全机制协作。
- **创建策略索引（聚合 doc_agent/AGENTS.md）**：此文件将聚合跨领域或模块的所有特定策略文档的引用。它的作用类似于策略的目录，使 AI 能够轻松发现它们。它将：
  - 列出领域特定或专门的策略（如"防护栏指南"、"文档运维策略"、"数据库运维策略"等），并提供指向这些文档中相关部分的稳定锚链接。例如，它可能有一个"数据库操作 – 参见 db/engines/postgres/AGENTS.md"的条目或锚定到统一的防护栏指南。
  - 本质上作为所有代理策略文档的映射，以便 AI 可以在其中搜索以通过关键字找到任何策略（而不是遍历整个树）。此文件将具有前置元数据，如 doc_kind: agent_policy_index（如果我们定义这样的角色）和 audience: ai。
  - 它不应复制全局规则或覆盖它们。它严格来说是一个索引；全局策略位于其上。它也不会包含实际的策略细节，只是链接或单行摘要，以保持轻量和专注。
  - 当触发器或编排器想要将 AI 指向特定策略片段时，此索引很有帮助：它们可以引用 doc_agent/AGENTS.md 中的锚点，该锚点重定向到实际文件，将触发器与原始文件路径解耦（使重组更容易而不破坏引用）。
- **模块级 AGENTS.md（对于需要它的每个模块）**：我们将定义何时以及如何使用本地策略：
  - 如果模块实例有任何特殊的执行逻辑或风险操作，它应该在 modules/<mod_id>/ 内拥有自己的 AGENTS.md。该文件是文档路由中的叶节点（它将被模块的 ROUTING.md 或策略索引中的条目引用），并包含特定于该模块领域的规则。
  - 模块 AGENTS 应涵盖本地关注点：例如，"模块 X 只能修改其自己目录中的文件"，或"模块 Y 中的操作需要通知模块 Z 的所有者"（如果存在此类交叉影响）。对于更简单的模块，这可能只是总结其功能、已知风险和任何模块特定的工具使用指南。
  - 如果模块的策略太复杂而无法整齐地适应（例如，模块本身有多个子域或场景），模块的 AGENTS.md 可以充当更详细策略文档的迷你索引或路由器（如其 doc 文件夹中的 policy.md 或其他指南）。但是，就我们的整体路由而言，模块的 AGENTS.md 是 AI 加载的终点；从那里，渐进式阅读可以引导它到子节或链接的文档（根据需要）。
  - 创建或修改模块的 AGENTS.md 将遵循与任何文档相同的流程：更新模块的 ROUTING.md 或父路由以确保它被引用，维护前置元数据等。我们将在贡献指南中强调，添加模块 AGENTS 需要更新文档路由（以便它不会被孤立）。
- **标准化所有代理策略文档的内容要求**：根据初始规范，每个代理策略文档（全局或本地）应包含某些部分以全面涵盖安全和流程规则。我们将使用此作为模板：
  - **访问控制**：列出该代理上下文中允许和禁止的操作、文件路径、命令等（例如"允许：在 module_X/ 下创建文件，禁止：在不归档的情况下删除客户数据等"）。
  - **执行防护栏**：定义执行期间必须发生的事情，例如必须通过的测试、必须更新的特定文档（如"修改 DB 模式时更新 CHANGELOG.md"）、任何必需的 dry-run 或批准步骤，以及如果某些事情失败的回退策略。
  - **工具和依赖**：列举 AI 在此上下文中可以使用的脚本或工具，以及任何先决条件。例如，"此模块的代理可以调用 scripts/calc_stats.py（注册为能力 ID X），并依赖于 Python 库 Y 可用"。如果某些命令有包装器，指示使用它们（例如，使用 make migrate 而不是直接调用 psql）。
  - **升级和日志记录**：指定触发升级的条件（例如，如果某个操作被触发器检测为高风险）、谁（角色或团队）需要批准，以及需要维护什么日志或 workdoc 条目（如"每当此防护栏触发时，将详细信息记录到 handoff-history.md 并标记 @DBA"）。定义如果 AI 遇到它无法满足的策略，应如何交给人类或回退流程。
  - **相关路由/能力**：提供相关路由或能力条目的交叉引用。例如，提及此策略涉及哪个 ROUTING.md 范围或主题（以便 AI 可以确认上下文），并列出与此策略密切相关的 ABILITY.md 中的任何能力 ID（用于快速查找）。这基本上将文档引用联系在一起，以便 AI 可以在它正在做的事情和管理它的规则之间跳转。
  - 这些部分将包含在全局 AGENTS 中（具有广泛的范围），并根据需要在每个模块的 AGENTS 中进行定制。我们将每个 AGENTS 文档保持在约 200 行以内，并使用要点或表格而不是长段落以提高清晰度。
- **设置维护和链接**：我们概述，每当添加/更改能力或触发器时，我们可能需要更新相关策略文档。变更管理流程将是：更新注册表/图 → 更新路由（如果需要）→ 更新策略（AGENTS.md）→ 更新能力索引（ABILITY.md）→ 记录在 workdocs 中。我们将在贡献工作流文档中记录这一点，以保持所有组件同步。
- **如果目录不允许任何执行**（例如纯粹是信息性的），它可以完全省略 AGENTS.md，如前面所述。此外，如果多个子目录共享相同的策略，我们可以允许在更高级别有一个中央 AGENTS.md，并让子路由引用它以避免重复。我们将确保我们的路由通过 related_routes 或类似的引用支持这一点。

**原理**：代理策略文档实际上是人类维护者和 AI 代理之间的合同。它确保 AI 的贡献保持在安全范围内并遵循项目约定，充当治理的内联文档。通过拥有全局策略，我们为所有任务设置了共同基础（AI 首先阅读此内容以内化全局规则）。通过拥有模块特定的策略，我们捕获每个领域的细微差别（例如，数据库更改与 UI 更改可能有不同的批准要求）。设计讨论强调了需要一个全局必读清单来加速 AI 的定位——这通过全局 AGENTS 阅读清单实现，因此 AI 从一开始就知道仓库的工作模式。策略索引（doc_agent/AGENTS.md）的分离防止在路由树中过多地引用策略，并允许触发器直接链接到特定规则，而不使策略本身成为路由逻辑的一部分。标准内容部分（访问控制等）确保在编写这些文档时不会忽视安全执行的任何方面，统一的结构有助于自动 lint 甚至 AI 代理检查它们的完整性。维护这些策略将是一项持续的工作；我们将通过将它们与能力和触发器的更改链接来强制执行更新（通过检查，如验证每个能力的 graph_node_id 是否与条目匹配，以及每个是否需要相应的策略条目）。最终，这些策略文档使 AI 能够在一定程度上自我调节，通过在继续进行操作之前在相关的 AGENTS.md 中检查"我被允许做 X 吗？"或"我必须遵循什么流程来做 Y？"。

**预期成果**：到 Phase 4 结束时：

- 根 AGENTS.md 将被编写，包含所有描述的部分（全局规则、阅读清单等）。此文档将有效地作为 AI 在仓库中工作的主要指南。
- 将创建聚合的 doc_agent/AGENTS.md 索引，其中包含链接到所有其他策略文档的条目（包括根策略或专门领域策略部分的锚点）。
- 每个需要它的模块都将有一个包含特定于其上下文内容的 AGENTS.md。对于初始模块（如将在后续阶段引入的 DB 和 API 的默认模块），它们的本地策略将在此阶段作为示例起草。
- 所有 AGENTS 文档都将具有适当的前置元数据（例如，doc_kind: agent_policy，如果它们对应于图节点，则为 graph_node_id 等）。我们将验证每个需要代理策略的高级能力节点都有一个记录在案并通过索引可访问的策略。
- 内容将通过代理 lint 工具进行验证：例如，一个脚本 agent_lint.py，它检查每个 AGENTS.md 的必需部分，确保它们的前置元数据与注册表一致（如果适用，每个都应列出 graph_node_id，并且该 ID 存在于图中），并验证它们引用的任何能力或路由实际存在。此自动检查将成为 make dev_check 的一部分。
- 有了策略，我们期望阅读这些策略的 AI 代理能够清楚如何安全地处理任务，触发器（Phase 8）在需要时将引用这些策略（例如，DB 模式更改触发器可以将 AI 指向策略文档中的"db-migration-policy"部分以获取说明）。因此，此阶段产生了将在后续开发阶段及以后管理 AI 行动的规则手册。

---

## Phase 5：模块化架构与模块初始化

**目标**：实现仓库的模块化架构，定义模块如何结构化、关联和初始化。此阶段确保可以使用脚手架以一致的方式向仓库添加新模块，并且模块层次结构、类型和实例的概念对 AI 和人类都清晰建立。

**范围**：Phase 5 中的关键任务和组件包括：

- **定义模块目录结构和命名**：所有模块位于 modules/ 目录下作为子文件夹。我们将模块文件夹命名标准化为 mod_<domain>_<name>（例如，mod_order_management 用于订单管理模块）。此命名方案允许轻松识别领域和功能，我们将通过 lint 检查来强制执行（以捕获任何不符合规范的模块名称）。
- **建立每个模块实例所需的内容**：创建新模块时，必须默认生成一组文件和子目录：
  - YAML 清单文件（例如 modules/<mod_id>/MANIFEST.yaml），捕获模块的关键元数据（其 module_type、对其他模块的任何依赖、作者等）。
  - 模块根目录中的核心 AI 文档文件：
    - `AGENTS.md`：模块的本地策略（如果模块有任何执行或特殊规则；参见 Phase 4）。
    - `ABILITY.md`：模块的本地能力索引，列出在该模块内定义的任何能力（这通过限定到模块的能力范围来补充全局能力索引）。
    - `ROUTING.md`：如果模块包含多个文档主题或子指南，则为模块的文档路由器。对于简单模块，这可能不需要（模块可以作为全局路由中的叶节点处理）。
  - 模块内容的标准子目录，例如：
    - `doc/`：用于额外的模块特定文档（指南、合同、与此模块相关的规范）。
    - `workdocs/`：用于模块特定的进行中笔记（尽管主要 workdocs 通常在仓库级别，模块特定任务可以在此处跟踪（如果需要））。
    - `config/`：用于模块配置文件。
    - 代码目录，可能包括 `backend/`、`frontend/`、`core/` 等，具体取决于技术（确切结构将遵循约定，例如，Web 模块可能有 api/ 或 service/ 目录）。
    - 模块创建期间的临时 `init/` 子目录（下面讨论）。
- **开发模块脚手架过程**：我们将实现一个脚本（例如，在 scripts/scaffold-module/ 下）以自动化模块创建。该过程：
  1. 交互式信息收集：AI（或开发人员）将提供或被要求提供必要的详细信息，如模块领域、名称、类型和任何初始配置（如是否连接到数据库等）。
  2. 脚手架脚本然后生成模块骨架：创建目录 modules/<mod_id>/，使用上面列出的文件填充它（使用提供的信息填充 YAML 前置元数据或清单中的占位符，例如，模块名称、类型、日期、所有者）。
  3. 它创建一个 modules/<mod_id>/init/ 文件夹，其中包含设置的任何临时资源——例如，脚手架用于生成模块的快速入门指南或问卷，或一些生成的示例/测试。此 init/ 文件夹在创建期间充当暂存区（例如，可能存储中间答案或模块的初始待办事项列表）。模块完全初始化和验证后，将删除此文件夹（想法是所有需要的内容要么在清单中，要么在文档中，任何临时说明不会混乱最终仓库）。
  4. 脚手架还将更新中央索引：它将向模块注册表 YAML（我们计划 doc_agent/modules/instance_registry.yaml）添加一个条目，列出新模块、其类型和关系。如果需要，它将更新根 README 或路由中的任何全局列表（例如，将模块添加到根文档中的模块目录表）。
  5. 如果模块预期具有公共能力，脚手架可能还会在全局能力注册表中插入一个骨架条目（初始成熟度为 candidate，稍后由开发人员/AI 完善）。
  6. 生成后，脚手架可以运行快速一致性检查：例如，以验证新模块的文档已链接（新模块的 ROUTING 包含在父路由中等）、命名正确，甚至可以执行占位符测试（如空测试通过）的模式运行 make dev_check。只有当这些都通过时，模块脚手架才被视为完成。
  7. 确认后，脚手架可以提示删除 init/ 文件夹并将模块标记为就绪。
- **定义模块初始化完成标准**：我们明确说明，当模块具有所有结构和文档元素（在索引中注册、路由可达、策略到位、任何能力或代码的占位符（如需要））时，模块被视为已初始化，但它不需要提供实际的业务功能。换句话说，脚手架后，模块将是空的真实逻辑（除了可能的一些模板代码或示例测试），这是可以接受的。目标是确保骨架通过所有检查并准备好填充。不完整的存根不应破坏 CI。这种方法鼓励小的初始 PR，仅添加结构，然后后续开发添加真实功能。
- **澄清模块概念：级别、类型、实例**：
  - **模块实例**：modules/ 目录中的具体模块（如 mod_order_core 用于订单核心服务）。这是开发和部署的实际单元。在执行方面，它是唯一的一等公民：所有能力和代码都在模块实例的上下文中运行。每个能力或低级方法都由模块实例拥有（通过 owner_module 字段），所有文档（workdocs、AGENTS 等）按实例维护。
  - **模块类型**：模块的抽象分类。类型用于强制执行一致性和已知模式（例如，"Controller"类型模块与"Service"类型模块，或对应于阶段的类型，如初始想法中建议的命名 1_Assign、2_Select 等）。我们将维护一个模块类型图（在 doc_agent/modules/type_graph.yaml 中），定义模块类型如何关联（某些可能依赖于其他，或形成分层架构蓝图）。此图充当设计蓝图，但不是运行时编排器直接使用的内容。每个模块实例在其清单中声明其 module_type，可能还声明它需要哪些其他模块（依赖项）。我们将通过 CI 强制执行：如果模块 A 需要模块 B，这样的关系必须被类型图允许（例如，如果类型图中这样定义，"UI"类型可以依赖于"Service"类型，但不能相反）。
  - **模块级别**：表示分层包含的概念（例如，产品可能包含不同有界上下文的子模块）。模块实例可以组织在父子树中（例如，功能的顶级模块可能有用于子组件的子模块）。每个模块清单可以包括 module_level 或指向 parent_module 的指针（如果它是子模块）。这主要用于人类理解系统结构，并可能影响文档分组。它与模块类型解耦（父模块和子模块可以是不同类型或相同类型）。级别层次结构也可能反映业务分解（如 Epic 包含 Features，Features 包含 Components 作为模块）。
  - 我们将在 AI 和人类文档中记录这些概念定义以提高清晰度。简洁的面向 AI 的指南（例如 doc_agent/guides/module.md）将解释三个概念（实例、类型、级别）及其角色。更详细的面向人类的文档（例如 doc_human/guide/modules.md）将详细说明如何决定模块拆分、类型如何结构化等，采用结构化格式。
- **在编排中管理模块关系**：编排的能力尊重模块边界很重要：
  - 能力（高级功能）将与单个所有者模块关联，编排器任务理想情况下不应一次性跨越多个顶级模块以保持清晰/责任。允许跨模块调用，但仅作为依赖项，而不是在一个上下文中的单独并行任务。例如，由 mod_order_core 拥有的能力 func.order.create 可能通过 depends_on 内部调用 mod_inventory 的能力（如果需要），但从编排器的角度来看，它仍在 mod_order_core 中执行单个高级能力。
  - 对于 AI 开发人员的视角，他们可以看到注册表中的所有能力（包括其他标记为 internal 的模块的能力），因此他们可以考虑重用内部的"轮子"而不是重新实现逻辑（如果合适）。但编排器（在生产规划中）不会直接调用内部的，为清晰起见，为每个编排目标维护一个模块。
  - 我们设置一个规则，即每个能力注册表条目必须包含 owner_module，任何具有 exposure: public 的高级能力被视为业务入口（如 API 或可由外部或编排器触发的工作流），而 exposure: internal 意味着它是一个助手，不直接调度。
- **规划模块移除和大型重构**：我们为模块级更改添加防护栏考虑。例如，删除模块应该是受控操作：
  - 应首先删除或重新分配模块的所有能力和文档（不能让孤立的能力残留）。
  - 必须检查对其他模块依赖项的影响；如果不确定，需要手动批准才能继续。
  - 我们强制（通过 Phase 8 中的触发器）AI 不能在一个操作中同时重构或删除多个模块——例如，触发器可以阻止一次触及太多模块目录的 PR，除非给出特殊覆盖。这确保更改保持本地化和可审查。
  - 这些规则将被纳入防护栏策略或触发器（如一个触发器，如果 AI 尝试跨越模块，则标记"模块边界"）。
  - 我们还在全局 AGENTS 或相关指南中记录这一点（以便 AI 知道对于重大更改，它应该一次专注于一个模块）。

**原理**：模块化架构为模板提供了可扩展性和可维护性。它允许不同的团队或 AI 代理在项目的不同部分工作而不会相互干扰，并帮助编排器通过分段任务来管理上下文。通过使用所有必要的文档和配置搭建模块，我们确保每个模块从一开始就是 AI 就绪的。讨论强调了消除"八个文档"的过时概念来生成，而是明确列出为模块需要创建的内容——我们的脚手架方法通过生成恰好需要的文件来解决这个问题，避免混淆。模块类型系统鼓励相似性质的模块之间的一致性，并帮助 AI 理解项目结构（"这些模块遵循模式，以定义的方式连接"），这可以改善其规划（例如，知道所有"controller"类型的模块应该调用"service"类型的模块）。类型图作为单一事实来源（SSOT）确保我们有一个维护的模块关系模型，我们可以使用它来验证清单声明，甚至可以根据需要自动生成系统架构图。通过不维护单独的手动图表给人类（可能会不同步），我们减少了文档漂移。围绕模块更改的防护栏解决了一个关键风险：AI 过于广泛的重构可能导致混乱；实施一次一个模块的规则可以缓解这种情况。所有这些措施旨在保持系统模块化、可理解并在演进过程中受控。

**预期成果**：到 Phase 5 结束时：

- 仓库将包括至少一个示例模块（可能是"base"或模板模块）完全搭建，展示结构，MANIFEST.yaml、AGENTS.md、ABILITY.md 等已就位。其他中心模块（如用于 API 的 api_gateway 模块，或如果以这种方式构建的 db 模块）也将在现在或它们各自的阶段搭建。
- 模块脚手架脚本将通过创建虚拟模块来实现和测试。它应该生成一个模块，其中在创建后立即运行 make dev_check 通过（意味着文档已链接，任何占位符测试通过等）。
- 实例注册表（instance_registry.yaml）将包含模块的条目（包含类型等），并且将创建类型图（type_graph.yaml）来描述允许的模块类型关系。CI 应包括检查，确保每个模块实例的 module_type 在类型图中定义，并且其声明的 requires_modules（依赖项）在该图中是允许的边。
- 文档：doc_agent/guide/module.md（面向 AI）将以约 100 行或更少的篇幅概述模块级别、类型、实例定义。相应的 doc_human/guide/module.md 将为开发人员提供更详细的说明，可能包括模块交互的示例或场景。
- 我们将更新全局 ROUTING.md 以包括一个枚举可用模块的部分（至少将它们作为导航的一部分列出）。例如，根 README/ROUTING 可以有一个模块摘要表和指向它们的快速入门或主文档的链接，以帮助 AI 轻松找到模块入口点。
- 防护栏/触发器配置（尽管在 Phase 8 中完全处理）将有占位符或初始规则，以确保模块添加运行所需的同步脚本（用于更新图和注册表），并且删除或多模块更改会被标记。我们将验证尝试在不遵循程序的情况下删除模块会触发警报。
- 有了模块化基础，我们可以继续在后续阶段进行领域特定的集成（DB、API），确信它们将正确插入此模块系统（例如，api_gateway 是特定类型的模块，DB 迁移可能属于 db 模块或类似）。基本上，到此阶段，将仓库扩展到多个模块的基础设施已就绪，并且初始模块已就位，以满足下一个功能的需要。

---

## Phase 6：数据库集成与数据管理自动化

**目标**：将数据库支持集成到模板中，包括结构化模式管理、迁移工作流以及用于 CRUD 操作和缓存（Redis）管理的 AI 代理。此阶段确保模板能够以受控、有文档记录的方式处理典型的数据库生命周期任务。

**范围**：Phase 6 专注于 PostgreSQL（主数据库）和 Redis（缓存）集成，按照初始要求，实现必要的代码基础设施和 AI 编排钩子：

- **设置数据库目录结构和资源**：我们将创建一个 db/ 目录（或者如果在 modules/db/ 下将 DB 作为模块处理；但是，由于 DB 涉及多个模块，它可能是共享资源目录）。按照初始设计：
  - **对于 PostgreSQL**：db/engines/postgres/ 将包含：
    - **一个 schemas/ 文件夹，其中包含描述每个表的 YAML 文件（tables/<tablename>.yaml）。这些 YAML 文件定义模式**：字段包含名称、类型、可空性、默认值、描述和标签（例如，标记字段是否为索引、外键等）。此结构化模式作为数据库结构的单一事实来源（SSOT）。
    - **一个 migrations/ 文件夹，其中包含 SQL 迁移脚本。迁移按时间戳对组织**：对于每个更改，一个 <timestamp>_up.sql 和相应的 <timestamp>_down.sql 用于回滚。我们将强制要求每个 up 迁移都有一个 down 脚本，并阻止像原始 DROP TABLE 这样的破坏性操作——而是倾向于将内容标记为已弃用，并在后续迁移中清理。
    - 可选地，一个 docs/ 子文件夹用于 DB 特定文档（如 DB_SPEC.md 或 YAML），这可能是总结数据库设计的面向 AI 的规范（初始验收标准提到了反映模式的 DB_SPEC.yaml）。
  - **对于 Redis**：可能在 db/engines/redis/ 下有类似的结构，用于任何 TTL 策略或缓存模式文档。Redis 通常不像 SQL 那样有模式，但我们可以在规范文档中记录预期的缓存键、数据模式和过期规则。
  - 我们将在 db/ 或 db/engines/postgres/ 中包含高级 README.md 或 ROUTING.md，说明如何导航 DB 文件（对于人类，因为 AI 将使用路由）。
- **实现用于数据操作的 AI 代理**：
  - 用于结构化数据（Postgres）的数据 CRUD 代理将包含在能力注册表中。这可能是一个高级能力（类型 agent 或 workflow），负责在受控条件下处理典型的 DB 任务——可能生成 SQL 查询、执行迁移等。例如，able.db.schema_manager 或 able.db.crud_operator 作为知道如何应用迁移或进行模式读取的代理节点。
  - 类似的 Redis 生命周期代理来管理缓存模式、确保键过期等。它可能包装某些操作，如在数据更改后刷新缓存等。模板将包含此类代理存根。
  - **在此阶段，当我们引入这些代理时，我们将**：
    - 将它们的低级能力添加到 method_registry（例如应用迁移的脚本、运行模式 lint 的脚本等），并将它们的高级定义添加到 ability_registry（具有适当的 owner_module，或者它们可能属于 db 模块或某个 ops 模块）。
    - **提供本地文档**：例如 db/engines/postgres/AGENTS.md，概述 DB 操作的策略（如生产环境迁移需要代码审查等），以及 db/engines/postgres/ABILITY.md 列出 DB 相关的能力（如果未在全局捕获）。
    - 确保这些代理也在编排器的注册表中注册，具有适当的 graph_node_id 和 tools_allowed 字段（工具是指它们可以调用的脚本，例如迁移脚本）。这将让编排器知道如何调用它们。
- **DB 工作流的自动化**：
  - **Linting 和验证**：我们将提供脚本，如 db_lint.py，以验证 YAML 模式定义（检查一致性、必填字段、命名约定），并可能将 YAML 模式与实际数据库进行比较（对于现有 DB），以捕获漂移。此外，migrate_check.py 可以在测试环境中模拟应用迁移，并验证它们与模式匹配并且可以干净地回滚。
  - **迁移过程**：仓库将包含标准迁移过程。可能有一个 Make 命令，如 make migrate 将新迁移应用到本地开发数据库，make migrate_check 运行验证（如没有缺失的 down 脚本等），make rollback_check 测试 down 迁移。我们在文档中定义，破坏性更改需要特殊处理（首先标记为已弃用）。当要求修改 DB 时，AI 代理将：
    1. 更新或创建 YAML 模式文件（tables/xyz.yaml）。
    2. 为更改生成一对新的迁移脚本。
    3. 可能更新高级规范或变更日志。
    4. 运行 make db_lint 和 make migrate_check 作为验证。
    5. 确保所有这些都记录在 workdocs 中，并在需要时获得批准。
  - **路由和文档**：在全局 ROUTING.md 中，我们将在范围（如"执行 – 数据库"或"数据管理"）下添加一个条目，包含相关主题（如"设计或更改模式"、"执行迁移"），将 AI 指向：
    - 数据库规范文档或模式指南（作为如何设计模式的快速参考）。
    - DB 操作策略（AGENTS.md）用于安全规则（如生产更改需要批准等）。
    - 数据/模式代理的文档（如果分开）。
    - 工具或脚本引用（如指向 make migrate_check 命令文档）。
    - 确保 AI 通过路由快速访问这些与 DB 相关的文档，意味着当它获得涉及 DB 的任务时，它将加载这些指南，而不会做流程外的事情。
- **DB 任务的触发器和防护栏**：数据库更改是高风险操作，因此我们将强制执行强触发器：
  - **例如，在 agent-triggers.yaml 中，我们将有一个条目，用于在 db/engines/**/migrations/** 中出现新文件（或模式文件被修改）时触发高优先级操作。此触发器（id**: db-migration）可能具有 enforcement: block（如果是生产或关键），需要防护栏批准。它将预加载文档，如 DB 策略和规范（以便 AI 知道规则），并列出 required_checks，如 db_lint 和 db_migration_dry_run（确保迁移可以在 dry-run 基础上运行）。
  - 防护栏策略将指定，任何尝试将迁移应用到生产数据库都需要明确的人工批准（AI 应通过批准步骤，将其记录在 handoff-history.md 中）。
  - 我们重申讨论中的观点，所有与 DB 相关的操作必须使用注册的能力/方法——AI 绝不应临时运行 SQL；它应始终通过我们定义的脚本或程序。配置设置可能决定这些脚本是针对本地开发 DB 还是云实例运行等，但这对 AI 是抽象的。我们将确保工具（脚本）本身处理环境定位，触发器确保使用正确的环境（例如，可能有一个触发器，防止在没有批准的情况下在生产 DSN 上运行迁移脚本）。
  - **额外的安全性**：可能有一个触发器来检测代码中任何直接的数据库连接使用，如果未通过允许的方法，则警告或阻止。
  - **文档和规范同步**：我们将确保有一个流程来保持 YAML 模式文件和任何导出的规范（如 ERD 或文档）同步。例如，如果我们将 DB_SPEC.yaml 作为统一视图（可能通过组合所有表 YAML 或包含跨表约束生成），我们应该在模式更改时更新它。AI 可以作为迁移过程的一部分完成此任务（例如，在编写新表 YAML 后，更新 DB_SPEC.yaml 中的部分）。CI 中的检查将比较模块的 db/engines/postgres/docs/DB_SPEC.yaml 与 doc_agent/specs/DB_SPEC.yaml 中的主副本，以确保它们一致。
  - **Redis 特定事项**：对于缓存，我们将在能力注册表中包含类似 cache_invalidator 方法的内容，或确保当数据更改时，编排有一个步骤来更新缓存。可能有一些触发器用于具有异常长 TTL 或高内存使用的键（但这可能超出初始范围，可能我们专注于确保 AI 可以执行基本的 set/get 并知道过期键或等待 TTL）。
  - **DB 更改的闭环**：所有 DB 操作应导致：
    - 更新的模式文档（以便文档永远不会过时）。
    - 更新的迁移脚本（版本控制）。
    - workdocs 中的日志（如"迁移 X 已应用/测试"）。
    - 可能更新 DB 的变更日志（可能是 CHANGELOG.md 或 workdocs/ledger 中的一行）。
    - 这确保 DB SSOT 和代码不会分歧。

**原理**：数据库管理被单独列为一个关键领域，需要与 AI 工作流仔细集成，因为数据的结构化特性和高错误风险。通过将模式表示为数据（YAML 文件），我们允许 AI 以受控方式推理和操作 DB 结构，而不是编辑原始 SQL，并且我们使运行验证更容易（因为我们可以 lint YAML 并自动生成 SQL）。要求总是成对迁移并避免直接破坏性更改强制执行安全迁移模式。为 DB 引入专门的 AI 代理确保 AI 关于数据的操作遵循引导方法（代理可以编码为执行诸如"首先更新模式 yaml，然后创建迁移，然后运行检查等"的操作）。迁移文件更改上的触发器充当安全网，捕获任何此类尝试并确保 AI 通过适当的程序和批准。这与讨论中的强调一致，即 DB 操作必须通过防护栏和触发器严格控制，因为它们的影响和对一致性（SSOT）的需求。此外，拥有正式流程意味着人类 DBA 或审查者可以轻松审计更改——所有内容都在 YAML 和 SQL 中，而不是隐藏在临时脚本中。编排器在此处的参与确保任何与数据相关的能力都通过预检查执行（如上下文使用跟踪可以测量 DB 查询是否经常失败以进行后续优化）。总体而言，Phase 6 将数据库最佳实践嵌入到模板中，使 AI 在此仓库的上下文中成为有能力和安全的数据库工程师。

**预期成果**：到 Phase 6 结束时：

- 仓库将包含 db/engines/postgres/ 目录，至少有一个示例表模式 YAML 和一对示例迁移脚本，作为未来迁移的模板。我们将测试通过 AI 代理添加新表的场景（如初始示例中描述的添加 orders 表），以确保工作流（模式文件 + 迁移 + 测试）正常工作。
- 一个 db/engines/postgres/AGENTS.md 文件（或全局 DataOps 策略文档中的集成部分）将概述特定于数据库更改的规则（如某些触发器需要批准、通知谁等）。它将具有前置元数据，标记为 agent_policy 和 audience ai。
- **数据 CRUD 代理和 Redis 代理能力将出现在 ability_registry.yaml 中，tier**: high，并添加相应的低级条目（脚本），例如：
  - 用于应用迁移的脚本（可能通过 make 命令或 Python 脚本调用）。
  - 用于检查迁移一致性的脚本（lint）。
  - 可能用于生成 ERD 或模式图的脚本（可选）。
  - 用于与 Redis 交互的脚本（如刷新键的缓存或监控键）。
  - 这些将在 ABILITY.md 或能力文档中记录，并通过我们的注册表检查验证它们的存在。
- 数据库操作的路由条目将生效，因此如果 AI 被询问 DB 任务，通过根 ROUTING.md 它将找到相关的 DB 条目，从而加载 DB 规范和策略文档。
- **所有围绕 DB 集成的 CI 检查都将运行**：在示例模式上运行 make db_lint 不会产生错误（证明我们的模式格式有效），make migrate_check 确认 up/down 同步并且没有禁止的操作。迁移的触发器将设置为 observe 模式或 block 模式（如适用），并在 dry-run 中测试（Phase 8 将涵盖测试触发器，但我们可能在此处模拟一个）。
- **重要的是，任何对数据库模式的修改都不能在不经过此文档化流程的情况下发生。此阶段的成功通过演示端到端示例来衡量（例如，AI 向表添加新列**: 它更新 YAML，编写迁移，通过检查，并需要通过防护栏代理的人工签署），并且一切都正确记录。Phase 6 之后，仓库模板已准备好可靠、安全地处理不断发展的数据模型。

---

## Phase 7：API 生命周期集成与管理

**目标**：将 API 开发和管理能力集成到模板中，涵盖从合同定义到实现、测试和网关编排的完整 API 生命周期。这确保模板支持快速设置 API 端点，具有强一致性检查和文档。

**范围**：Phase 7 专注于 RESTful API（或类似）支持，包括合同优先开发和网关模块设置：

- **初始化 API 网关模块**：我们将创建一个模块（例如 modules/api_gateway），作为外部 API 调用的入口点。此模块将使用我们的 Phase 5 流程搭建，包含：
  - AGENTS.md – 包含网关级别的路由、身份验证、速率限制等策略。
  - doc/ROUTING.md – API 主题的路由（例如，区分不同 API 集的范围）。
  - doc/CONTRACT.md – 此文件描述网关模块本身的 API 合同（如全局端点或内部服务如何暴露）。
  - doc/MIDDLEWARE.md – 详细说明在网关上应用的任何中间件或横切关注点（日志记录、身份验证）。
  - 这些为公开 API 的模块如何记录自己提供了模板。
- **为每个模块建立 API 合同文件**：提供 API 端点的任何模块将在其 doc/ 目录内有一个 doc/CONTRACT.md 文件。此合同文件：
  - **使用 Markdown，具有指示 audience**: ai、doc_role: contract、route_role: leaf 等的前置元数据。
  - 列出模块的端点（包含方法、路径、身份验证要求），并可能通过 JSON Schema 或类似方式定义请求/响应模式（这些可以直接包含或通过引用模式文件）。
  - 此合同作为该模块 API 接口的单一事实来源，将用于客户端生成和兼容性检查。
  - 对于版本控制，我们可能有一个隐藏目录（如 .contracts_baseline/）来存储合同文件的快照，用于版本之间的兼容性检查。
- **合同合规性和生成的自动化**：
  - 提供一个脚本或工具来执行合同兼容性检查（例如，scripts/contract_compat_check.py）。这将比较模块的当前 CONTRACT.md 与基线（.contracts_baseline/ 中的先前版本或已知良好版本），以确保在没有适当版本控制或警报的情况下不会引入破坏性更改。这可以捕获诸如删除端点或更改模式等会破坏客户端的内容。
  - **提供 OpenAPI 生成步骤**：脚本 scripts/generate_openapi.py，读取所有 CONTRACT.md 文件并为整个 API 生成聚合的 openapi.json（或 YAML）定义。这确保文档和客户端存根可以自动派生。我们将包含一个 tools/openapi.json 文件（或类似），该文件由此脚本更新。
  - 提供客户端类型同步工具（可能是 scripts/type_contract_check.py），确保代码中的数据模型与合同匹配（或更新客户端库）。例如，如果我们从 OpenAPI 规范生成 TypeScript 类型或 Python 数据类，此脚本验证它们是最新的。
  - 这些脚本将集成到 CI 中（以便任何触及合同文件的 PR 必须运行 make contract_compat_check 等），并可能集成到触发器中（见下文）。
- **在编排器中注册 API 能力**：
  - API 网关代理（模块）将添加到编排器的能力图中。例如，能力 ID 如 able.api_gateway.v1，类型为 agent，表示 API 编排逻辑（如它将调用路由到适当的模块能力）。此代理可能在 tools_allowed 中列出它使用的低级实用程序（如合同验证脚本、openapi 生成器）。
  - 具有 API 端点的每个模块可能获得一个代表其服务的高级能力（例如 able.order_service.api，类型为 workflow，网关调用它）。但通常，API 调用可能一对一映射到模块中已经作为公共能力存在的能力。
  - 我们确保对于每个 CONTRACT.md，描述的端点对应于特定的模块能力，或者由网关路由到模块方法处理。此映射可以在合同内记录（如将端点链接到处理程序的能力 ID）。
- **文档和路由**：
  - **在根 ROUTING.md 中，创建 API 执行的范围。例如**：Scope: "执行 – API"，Topic: "端点生命周期"，When: "设计或更改接口合同"，目标文档为：
    - API 网关 ROUTING.md 和 AGENTS.md（以便 AI 可以导航到 API 网关模块文档）。
    - 可能包含 tools/openapi.json（规范输出），通过描述如何使用它的小文档包装（以便 AI 如果需要推理整个 API，可以加载 OpenAPI）。
    - 如果涉及特定模块的 API，则为相关模块的 CONTRACT.md。
    - 基本上，我们根据上下文将 AI 路由到网关文档或直接路由到模块的合同文档。
  - 每个模块的 ROUTING.md（如果足够复杂）也应将其 CONTRACT.md 作为叶节点引用包含。
- **API 更改的安全和批准流程**：
  - **API 更改可能与 DB 更改一样敏感（破坏客户端等），因此触发器将监控它们。例如，agent-triggers.yaml 中对任何 modules/*/doc/CONTRACT.md 或生成的 openapi.json 的更改的条目将被标记为 critical 或 block。触发器可能是 id**: contract-change，enforcement: block，在检测到 API 合同编辑时，预加载"API 更改防护栏指南"并要求某些检查（如运行合同兼容性脚本）。
  - 此触发器的防护栏代理将确保 AI 运行兼容性检查，并且可能有人批准重大更改（特别是如果破坏性的）。
  - 此外，如果 OpenAPI 规范已更新，可能自动提出审查以确保文档已发布等。
- **执行指南**：
  - **提供用于进行 API 更改的分步 SOP（标准操作程序）。我们可能包括指南或清单（如汇总阶段的表格**：需求和设计、实现、测试等，每个阶段必须执行的操作）。在初始内容中，有一个包含 API 更改执行表格的部分 7.8 – 我们可以将其作为 AI/人类可以遵循的指南：
    1. 设计：使用新端点和模式更新 CONTRACT.md，运行 make contract_compat_check 以验证没有意外的破坏。
    2. 规划：在 workdoc 计划中记录更改，包括任何跨模块影响。
    3. 实现：在模块的后端编写处理程序代码，确保它遵守合同（使用示例负载进行测试）。
    4. 测试：为端点编写或更新集成测试，运行 scripts/generate_openapi.py 并使用它生成客户端并针对它运行测试。
    5. 文档：确认 openapi.json 已更新并提交它，并确保任何示例或指南反映新端点。
    6. 批准：如果触发器要求，获得部署更改的批准（特别是如果它是破坏性更改）。
    7. 文档中的表格有助于确保不遗漏任何步骤（AI 可以受其指导）。
- **API 集成的验收标准**：
  - 所有 CONTRACT.md 文件都具有完整的前置元数据并在路由中注册。
  - tools/openapi.json（或类似）应始终反映最新的合同（我们可能通过在 CI 中重新生成它并在存在差异时失败来强制执行）。
  - make contract_compat_check、make generate_openapi、make type_contract_check 的 CI 运行对于基线（初始合同）应该通过，没有错误。
  - 我们可能还想确保重新生成客户端类型是幂等的（脚本可以随时重新运行，如果没有合同更改，结果不应更改）。
  - 记录客户端（如果包含，例如 TypeScript 类型）已相应更新。

**原理**：API 集成对于使仓库能够作为实际服务开发的起点至关重要。通过强制执行合同优先方法（使用 CONTRACT.md 文件和自动检查），我们防止了 API 漂移（实现和文档分歧）的常见陷阱。合同成为 AI 和人类的共享真相：AI 将查阅它来了解存在哪些端点以及它们期望什么数据，人类可以审查它以确保它满足要求。OpenAPI 生成自动化文档和客户端更新，减少手动工作和错误。围绕合同的触发器和批准反映了 API 更改的高影响——它们确保任何更改都经过审查（如果 AI 正在更改，这很重要，以避免意外破坏外部集成）。通过将这些集成到模板中，即使是全新的项目也能从第一天起就获得强大的 API 治理。API 网关模块封装了横切关注点（身份验证、速率限制），将它们与业务模块解耦——它还提供了一个单一位置来执行全局 API 策略（如如果我们需要关闭端点，网关可以通过策略执行）。修改确认，除了加强合同管理和接口更改的防护栏的重要性外，不需要重大的结构性更改，我们已经通过触发器和专注于批准来纳入这一点。

**预期成果**：到 Phase 7 结束时：

- modules/api_gateway/ 模块已完全设置，包含其文档和策略，并出现在 API 范围内的全局路由中。编排器注册表包括 api_gateway 代理的条目，可能还有一些初始工具（如基本健康检查端点能力）。
- 至少有一个其他模块（如 mod_example_service）有一个 doc/CONTRACT.md，说明模块如何定义其 API 合同。我们将通过在那里添加一个示例端点并验证 OpenAPI 生成拾取它并且合同检查通过（即基线已更新）来测试流程。
- 运行 OpenAPI 生成器会产生一个与合同匹配的有效规范文件。此规范可用于生成简单的客户端（我们可能测试生成一个以确保管道工作，尽管实际客户端代码可以被视为超出范围，更多的是验证一致性）。
- **合同更改的触发器处于活动状态**：有意编辑 CONTRACT.md 而不更新基线或运行检查应导致 CI 失败或至少警告。要求对重大更改进行批准的防护栏流程已到位（可能通过将合同更改标记为破坏性并看到 priority: critical 触发器触发，指示 AI 获得批准来模拟）。
- 在文档方面，可能添加 API 指南（对于 AI，如果路由和策略涵盖它，可能不需要，但对于人类，doc_human/guide/api.md 中的简短指南可以总结如何按照这些步骤添加新端点）。
- Phase 7 完成后，我们的模板可以支持通过 AI 驱动或半自动过程添加新的 API 端点，高度确信不会遗漏任何内容（文档已更新、测试已运行等），从设计到文档形成闭环。

---

## Phase 8：自动化管道与触发器系统

**目标**：在仓库中实现自动化代码开发管道（检索 → 规划 → 编码 → 写入 → 更新上下文），主要通过可配置的触发器系统。这确保某些事件或条件自动引导 AI 的行为、执行防护栏并维护上下文，使开发更加自主和安全。

**范围**：在 Phase 8 中，我们专注于将早期阶段构建的部分连接成连贯开发循环的自动化钩子：

- **设计触发器机制**：我们将触发器形式化为 YAML 定义的规则（可能在 doc_agent/triggers/agent-triggers.yaml 中或在 doc_agent/orchestration/ 下）。每个触发器具有：
  - 一个 id（我们采用命名约定，如 <domain>.<scope>.<action> 以清楚地传达其意图）。
  - 优先级级别（例如，P0、P1、…，其中 P0 最高）。如果多个触发器同时触发，此优先级将确定执行顺序。
  - **强制执行模式**：例如 observe（仅记录）、warn（警告 AI 但允许继续）或 block（暂停直到批准）。
  - 匹配条件，可以基于文件系统事件（如文件路径模式、内容正则表达式）或 AI 输出（如检测到执行某些风险操作的计划）。目前，大多数触发器将是文件中心的（如检测某些目录中的修改、提交消息中某些关键字的存在等）。
  - **preload_docs**：触发器触发时自动加载到上下文中的文档列表（带有可选锚点）。例如，如果触发器检测到 DB 迁移文件添加，它会为 AI 预加载 DB 迁移策略部分。
  - **required_checks 或 actions**：触发器激活时必须运行（并通过）的命令或脚本调用列表。例如，对于迁移触发器，required_checks: [db_lint, db_migration_dry_run] 以确保运行这些验证。
  - 可能有一个 target_agent 或 target_function 引用，指示此触发器正在保护或关联的高级能力（尽管我们还在能力中有 safety_profile 链接回来）。我们可能使用它来允许编排器识别要启动的工作流。例如，如果触发器是关于"推送到主分支"，target 可能是某个 CI 能力管道。
  - **分组或互斥**：可能是触发器组或互斥的概念，以避免冗余触发，但这可能是高级的。我们可以记录"互斥组"的概念或触发器可以在需要时相互覆盖（但初始方法更简单）。
- **实现触发器评估逻辑**：实际上，触发器将通过以下方式评估：
  - 编排器在 AI 规划期间主动评估（例如，如果 AI 提出一个操作，我们模拟会触发哪些触发器），以及开发环境中的文件监视机制（例如，git pre-commit 钩子或运行 make trigger_check 以查看是否有任何触发器与更改相关的 CI 步骤）。
  - 我们将提供一个脚本 trigger_check.py 或将其合并到 make trigger_check 中，该脚本遍历每个触发器规则并检查当前更改集或上下文是否满足其条件，输出任何匹配项。
  - **编排逻辑（phase 10）将详细说明触发器如何与代理的决策循环集成（基本上**: 在执行步骤之前，检查触发器；如果任何 block 触发器触发，暂停并升级）。
- **处理并发触发器和优先级**：讨论明确提到处理多个触发器的场景：
  - 如果多个触发器匹配，我们将按优先级排序并首先处理最高优先级。较低优先级的触发器可能排队或记录供稍后处理。
  - 我们还确保，即使较低优先级的触发器没有执行操作，其发生仍会在某处记录（如在工作文档上下文中）以供了解。
  - 这是通过向每个触发器添加 priority 字段并通过编码评估以按该字段对触发器排序来实现的。
  - **示例**：触发器 A（P0，block）和触发器 B（P1，warn）都触发。系统将首先处理 A（阻止并需要解决）。B 的条件被记录（可能在上下文中写入警告），但如果 B 的操作会同时发生，B 的操作可能会被跳过。或者，如果 B 不冲突，它仍然可以执行。我们在触发器防护栏设计中记录此行为。
  - 还提及触发器是否属于互斥组（例如，如果它们相互矛盾，一个可能抑制另一个，但我们可能最初不会实现这一点；只是记录我们考虑了它）。
- **要实现的触发器示例**：
  - **高风险文件更改触发器**：例如，修改 modules/*/AGENTS.md 可能触发提醒 AI 更新 doc_node_map.yaml 并且不要复制全局规则。
  - **批准触发器**：例如，对 tools/openapi.json 或 CONTRACT.md 的任何更改都会触发防护栏，如 Phase 7 中讨论的。
  - **运维触发器**：例如，检测到 scripts/ 目录中的新脚本触发注册它的过程（或至少如果未注册则警告）——我们可能有一个触发器，如果在 scripts 中添加了 .py 文件但在 method_registry.yaml 中没有条目，它会标记这一点。
  - **多模块更改触发器**：如果提交触及多个 modules/<name>/ 目录中的文件（可能除简单文档外），触发警告以确保 AI 不会一次进行跨模块重构（与 Phase 5 关于专注于一个模块的防护栏相关）。
  - **Workdoc 触发器**：例如，如果 workdoc 超过某个大小或年龄，触发器可能注意到它需要归档（尽管实际归档是通过 CI 而不是立即的，根据修改，但触发器可以安排它）。
  - **质量触发器**：例如，如果测试失败或 lint 失败，触发器可能捕获这一点并将 AI 路由到修复它（尽管测试失败更像是事件结果而不是静态触发器）。
  - 许多触发器涉及文件事件（这自然适合 pre-commit 或 CI 检查）。对于实时循环中的 AI 操作，触发器还可以监控 AI 计划或输出中的某些词语并做出反应（如如果 AI 说"我将禁用所有防护栏"，内容触发器可能会干预）。
- **"链"的自动化（检索→规划→编码→写入→上下文）**：我们将记录并部分实现 AI 任务如何流动：
  1. 检索：编排器使用路由系统（Phase 2）获取相关文档。
  2. 规划：AI 制定计划。此时，触发器可以应用于计划内容。（我们可能对某些计划关键字（如"删除模块"）有模式触发器，这可能提示谨慎）。
  3. 编码：AI 编写代码或文档。当它产生工件时，文件更改上的触发器可能触发（例如，它创建迁移文件，因此 DB 触发器触发并加载策略，要求测试）。
  4. 写入/执行：更改被应用或测试。此处的自动化意味着当触发器触发时自动运行必需的检查（我们可以与 makefile 集成，以便在保存文件时运行相关检查）。
  5. 更新上下文：workdocs 更新发生的情况。某些触发器明确要求向上下文或 workdoc 添加条目。例如，防护栏触发器可能要求 AI 在 context.md#Triggers 中记录哪些触发器触发以及做了什么。
  - **我们将这些步骤整合到自动化指南中**：例如，一个内部 automation-links-guide.md，描述触发器、路由和防护栏如何通过链交互。这主要是供 AI 在需要时参考链的一站式说明。
- **通过触发器的定期维护**：某些触发器或自动化任务不是基于立即事件运行，而是按计划运行（如 CI 夜间作业）：
  - 例如，一个计划触发器每周运行 guardrail_runner.py --dry-run all 以测试所有强制执行流程。
  - 一个计划作业运行上下文清理（我们在 Phase 10 中添加了动态上下文管理，但调度可能在 CI cron 中完成）。
  - 我们将计划在文档中添加这些作为注释，并确保存在支持它们的脚本。
- **CI 集成**：许多触发器对应 CI 检查。我们将合并在 CI 中运行 make trigger_check，它在 dry-run 中模拟所有触发器，以确保没有任何新更改触发未解决的阻塞。如果任何 block 触发器出现但没有解决方案或批准，CI 应使构建失败，强制关注。
- **AI PR 审查集成**：修改讨论提出了在自动化链中使用 AI 进行 PR 审查的想法。这是一个高级增强。我们将其作为考虑事项：可能有一个触发器，当打开 PR 时调用 AI 审查代理来检查代码和文档。这可能现在不会实现，但我们将记录这个想法，并可能为其留下钩子（如路由中的条目或注册表中的可选能力）。这可能是未来的 Phase 或稍后的可选管道。

**原理**：带有触发器的自动化管道将我们之前的所有工作结合在一起，真正实现了带有防护栏的 AI 驱动开发。触发器充当主动哨兵，捕获可能滑过被动策略文档的条件。通过自动加载正确的指令并运行检查，它们大大提高了 AI 的效率和安全性：AI 不必搜索要运行哪些测试——触发器通过 required_checks 要求它；AI 不会意外提交没有批准的迁移——触发器阻止它并强制防护栏流程。触发器的优先级处理了重要的边缘情况：多个问题同时发生。我们确保 AI 首先处理最关键的问题（例如，安全问题优先于轻微警告）。在上下文中记录所有触发器命中（甚至那些没有立即处理的）有助于保持态势感知——对于后续步骤中的 AI 和人类审计员都是如此。实际上，触发器实现了 AI 的一种反射性反馈循环：一旦它做了某事，环境就会通过触发器做出反应，引导下一步行动。触发器定义和相关文档的仔细设计确保这种反射是透明和一致的。

**预期成果**：到 Phase 8 结束时：

- agent-triggers.yaml（或等效项）将填充一组定义良好的触发器，涵盖已知的高风险或关键工作流节点（如上述示例）。每个都将有明确的操作和文档引用。
- **我们将有一个新的自动化指南文档（可能是 doc_agent/flows/automation-links-guide.md），描述自动化链如何工作、触发器是什么以及如何解释它们。此文档（audience**: ai，doc_role: guide）将作为 AI 在需要回忆或解释自动化过程时的参考。
- 维护计划（在 ai/workdocs/active/maintenance/plan.md 或类似位置）将列出常规自动化任务（如每周防护栏 dry-run、定期上下文清理等），并且我们将设置 CI 或脚本来执行这些任务。
- **测试成功**: 模拟具有多个触发器的场景。例如，创建一个虚拟情况，其中添加迁移（DB 触发器）和编辑合同（API 触发器）在一个批次中发生。确保系统首先处理 P0 触发器（假设 DB 是 P0，API 是 P1），适当地阻止并记录两个触发器。然后验证在解决 P0（批准迁移）后，它处理 P1。这可以通过防护栏脚本中的 dry-run 模式完成。
- make trigger_check 将包含在 make dev_check 或类似项中，以便任何开发人员或 AI 提交都将通过触发器运行，如果存在任何未解决的 block 触发器，将失败。我们可能将某些触发器标记为允许挂起（如如果它们需要实际的人工批准，CI 可以检测批准工件）。
- 所有上述内容确保在进入实际开发（Phase 10 交互式开发，以及 Phase 11 测试）时，为高度自动化和安全的开发周期奠定了基础。

---

## Phase 9：脚本管理与工具约定

**目标**：定义仓库中脚本和工具的组织、注册和质量标准，确保它们易于被 AI 发现并一致地集成到能力索引和自动化管道中。

**范围**：在 Phase 9 中，我们专注于 scripts/ 目录和相关流程：

- **构建 scripts 目录结构**：我们将强制执行所有实用脚本的清晰布局。例如：
  - **根 scripts/operations-guide.md，这是面向 AI 的脚本域入口点（具有 audience**: ai，doc_role: guide）。此指南将描述脚本如何组织、命名约定以及如何使用/扩展它们。它还充当规范路由器 – 关于脚本的触发器或 AI 查询将指向此处。
  - 面向人类开发人员的根 scripts/README.md，概述脚本结构并链接到 operations-guide.md 以获取详细信息。
  - scripts/ 下的子目录按目的分组（例如 scripts/db/ 用于数据库相关脚本，scripts/ci/ 用于 CI 自动化，scripts/scaffold-module/ 用于脚手架等）。每个子目录可以有自己的 README 或至少在 operations-guide 中有一个指向它的条目。
- **强制执行脚本命名和标头约定**：所有非临时脚本（作为仓库能力一部分的脚本，不仅仅是一次性的）必须：
  - 遵循命名约定（小写，单词由下划线或连字符分隔，取决于语言标准）。
  - 包含标准化的标头注释或 YAML 前置元数据，描述其目的、用法、参数和任何可用的风险/dry-run 模式。例如，Python 脚本可能以列出用法的块注释开头，或者 shell 脚本在运行时使用 -h 时可能会回显用法。我们可能在注释中的小 YAML 序言中形式化这一点。
  - **这些标头详细信息应与文档同步**：scripts/operations-guide.md 将有一个部分列出每个脚本和关键信息（例如它做什么，它在什么能力 ID 下注册）。当我们更新脚本标头的标准时，我们首先更新指南，然后传播到所有脚本，以保持一致性。
  - 可能定义一个要包含的脚本文件模板（如新脚本可以作为起点的注释模板）。
- **脚本的能力注册**：任何旨在由 AI 或自动化进程调用的操作脚本必须在 capabilities.yaml（方法注册表）中注册。我们将此集成到开发工作流中：
  - **如果在 scripts/ 下添加新脚本，开发人员/AI 应运行脚手架来注册它。我们可能创建一个小 CLI 或清单**: scripts/operations-guide.md 将包括一个"如何添加新脚本"部分来说明这一点。它将指示：
    1. 首先搜索现有脚本是否满足需求（以鼓励重用）。可能提供使用 rg（ripgrep）的命令或引用 CAPABILITIES.md 以查找类似的能力。
    2. 如果未找到，继续实现新脚本，然后更新能力注册表。在 method_registry.yaml 或 capabilities.yaml 中为其添加新条目。还更新 operations-guide 中的"能力注册"部分，包括步骤和与脚本相关的任何能力 ID 命名约定。
    3. 此外，在 operations-guide.md 中的相关类别下记录新脚本（以便 AI 有一个一目了然的参考）。
    4. 如果脚本应由某些事件触发，确保在 trigger_map.yaml 或触发器文档中添加/更新条件->脚本的触发器。
  - 不会有未注册的脚本用于 AI 使用；任何未注册的脚本将被视为临时或仅由人类访问的内部脚本。
- **脚本的触发器映射**：维护触发器到脚本的映射（反之亦然），可能在 trigger_map.yaml 中或在 operations-guide.md 的附录中。这帮助开发人员看到，例如，"当触发器 Y 触发时调用脚本 X"和"触发器 Y 监视文件模式 Z 并调用脚本 X"。保持此最新确保自动化的透明度。我们可能将此矩阵嵌入文档中，以避免单独的事实来源（可能从触发器配置自动生成）。
- **脚本重用和版本控制策略**：我们注意到策略：
  - 在编写新脚本之前，搜索现有脚本（指南强调这一点）。
  - 我们不鼓励重复功能；如果需要，重构现有脚本以覆盖新用例，而不是创建近似的重复项。
  - **对于版本控制**：如果脚本的接口需要更改（破坏性更改），将其视为 API 更改 – 可能将旧脚本标记为已弃用并创建新 ID 或需要增加某些版本字段。
  - **可能包含关于脚本弃用的注释**：如何标记和淘汰旧脚本（可能通过注册表中的标签）。
- **文档集成**：顶级 scripts/operations-guide.md 将：
  - 呈现脚本目录及其用途的概述。
  - 提供快速参考"命令备忘单"，列出重要的 make 命令或脚本命令及其作用（特别是 AI 可能需要运行的命令，例如 make dev_check、make db_lint 等）。
  - 概述使用脚本的 SOP（如"运行任何脚本，如果可用，优先使用 Make 命令，否则直接使用 python scripts/... 调用 Python 脚本"）。
  - 如果脚本需要某些环境或配置，请提及它。
  - 如果脚本具有 dry-run 模式（关键脚本应该具有），请说明如何调用它。
  - **链接到任何相关策略**：例如，提及如果脚本有副作用，它们有一个防护栏。
  - 可能在文档中嵌入添加新脚本的清单（如上述所述）（设计提到了"新增脚本流程"，这意味着一个添加过程）。
- **脚本的质量和测试要求**：我们设置标准以确保脚本健壮：
  - **复杂性**：例如，我们力求函数的 McCabe 复杂度低于 10（如果超过，通过注释证明或将其分解）。
  - **Linting**：所有脚本必须通过特定于语言的 linter（Python 的 PEP8、shell 的 ShellCheck 等）。
  - **Dry-run**：执行更改的脚本（如应用迁移、运行破坏性操作）应具有 --dry-run 选项，模拟更改或至少输出计划而不应用。我们强制记录这一点并测试它。
  - **日志记录**：脚本应记录其关键操作（特别是如果它们在 CI 中运行或作为自动化的一部分，以便我们具有可追溯性）。
  - **测试**：如果脚本复杂，理想情况下有一个小型测试脚本，或至少在 CI 中合并一个测试（可能使用示例场景）。
  - 这些要求将在 operations-guide.md（质量部分）中记录，并可能通过 CI 强制执行（如运行 linter，通过工具测量复杂度等）。
- **测试脚本框架**：我们可能会添加一个虚拟脚本来演示该过程。例如，如果尚未完成，scripts/example.py 带有标头，正确注册，可能用于虚拟触发器，以便我们可以端到端看到它。
- **临时脚本**：我们澄清，任何以 _temp 为后缀并放置在 temp/ 目录中的脚本都免于注册，并将定期清理。这些可能是真正的一次性脚本或调试脚本，触发器通常应忽略它们。

**原理**：scripts 目录包含 AI 或 CI 可能调用的实际可执行工具 – 它们是许多低级能力的实现。在这里拥有强约定对于 AI 正确使用它们以及维护者不丢失跟踪至关重要。通过提供操作指南并确保所有脚本都被索引，我们使脚本可以通过 AI 查询发现（AI 可以在 operations-guide 中搜索以找到执行 X 的脚本）。注册确保每个脚本都被视为 AI 能力集的一部分（没有 AI 不知道的影子操作）。脚本的质量门控至关重要，因为这些脚本可能作为影响数据或生产的自动化作业运行；我们确保它们可靠和可审计。此外，通过记录添加脚本的过程，我们纳入修改说明，即脚本应通过注册脚手架添加，而不是临时添加 – 这保持了我们的方法注册表的一致性。

**预期成果**：到 Phase 9 结束时：

- scripts/operations-guide.md 已就位，并详细记录脚本约定、组织和流程（涵盖从命名到添加到测试的要点）。在处理脚本时，它可能是 AI 和人类的主要参考。
- 在早期阶段引入的所有初始脚本（如 doc_node_map_sync.py、registry_check.py、guardrail_runner.py 等）都在此指南中记录，并具有符合我们格式的标准化标头。它们的条目存在于 method_registry.yaml 中（带有适当的 ID 和标签）。
- 能力索引（ABILITY.md）已更新以反映基于脚本的能力（尽管 ABILITY.md 专注于高级，它可能列出包装多个脚本的能力 – 我们确保它与方法注册表之间的一致性）。
- **CI 管道运行脚本质量检查**: 例如，一个组合的 make lint，包括脚本 linting、复杂度检查等。我们将测试添加格式错误或过于复杂的脚本会触发 CI 失败。
- 触发器矩阵（或映射）在文档或 YAML 文件中编译，我们运行检查以确保它与触发器配置匹配（以避免文档漂移）。
- Phase 9 之后，仓库的操作工具已很好地编码化。这意味着 AI 应该很少对如何运行特定的维护任务感到困惑 – 它可以参考操作指南，找到脚本以及如何调用它，甚至在那里看到示例用法或注意事项。对于维护者，加入新脚本遵循一个清单，确保不会遗漏任何内容（如更新文档或注册表）。

---

## Phase 10：交互式开发工作流与上下文管理

**目标**：实现使用 AI 代理进行交互式项目开发的框架，确保在整个规划、执行和迭代循环中，上下文得到保留并应用防护栏。此阶段专注于编排器防护栏行为、用于上下文的工作文档以及动态上下文管理。

**范围**：Phase 10 将编排和上下文处理结合在一起，以支持交互式开发循环：

- **定义编排层和职责**：澄清编排器和防护栏如何交互：
  - 控制层（顶级编排器和防护栏代理）位于根目录。此处的资源包括根 ROUTING.md、全局 AGENTS.md、触发器配置（agent-triggers.yaml）、注册表（registry.yaml，如果使用则为 trigger-map.yaml）。编排器使用这些来决定将任务委派给哪个模块或工作流，防护栏使用它们来拦截策略违规或特殊条件。
  - **模块级编排器（模块代理）**: 如果需要，模块可能有自己的编排逻辑，或者至少在它们的 AGENTS.md 中定义的代理，执行本地规则。但通常，任务要么由全局编排器编排，要么由模块能力直接执行。为简单起见，我们将编排器视为一个可以调用模块能力的实体。
  - **防护栏代理**: 一个专门的代理/策略执行器，在具有 block 强制执行的触发器上介入。它负责执行批准工作流、暂停执行直到满足条件等。我们将其视为编排层的一部分，因为它介导正常编排被安全考虑覆盖的情况。
  - 在指南中（或在 AGENTS.md 本身中）记录每个层的作用，例如，编排器编排任务和路由，防护栏批准/阻止风险操作，模块代理确保本地合规性。
- **触发器到代理策略到执行流程（钩子集成）**: 概述并实现触发器事件如何通过执行：
  1. 触发器触发 – 例如，检测到事件（文件更改或计划内容）。
  2. 编排器/防护栏加载指定的 preload_docs（策略、指南）以获取上下文。
  3. 如果强制执行是 block，防护栏代理接管控制。AI 现在应遵循防护栏程序：
     - **检查策略中需要什么**: 可能需要人工批准或先运行 dry-run 等。
     - 防护栏代理可能产生消息或必需的清单（如"需要 X 的批准。您是否运行了 Y 检查？"）。
  4. AI（或系统）必须满足 required_checks – 例如，运行列出的脚本并收集它们的输出。
  5. 防护栏然后要么在检查通过且条件允许时自动批准，要么等待人工（对于关键触发器）。也许系统可以允许为非关键或测试环境触发器配置自动批准。
  6. 一旦获得批准或不需要，执行恢复 – 编排器要么继续计划（如果批准），要么中止/回滚（如果拒绝）。
  - **我们实现一个简单的防护栏批准接口**: 可能在 workdocs/active/context.md 中名为"Approval"的部分，人类可以在其中放置一个"由 ... 批准"的注释，AI 可以检测到，或者仓库中的标签（在实际使用中，可能是 PR 评论或由批准者更新的特定文件）。
  - 如果未批准，防护栏代理应启动回滚步骤（如果任何更改已部分应用）。例如，如果部署完成一半并被阻止，则回滚它（这可能不会在本地开发上下文中经常发生，但为了完整性）。
  - **记录结果**: 每个触发器事件和防护栏决策都记录到 ai/workdocs/active/context.md 的相关部分（如 #Triggers 或 #Automation），如果它是路由健康的永久记录，也会追加到 ai/maintenance_reports/route-health.md。
- **Workdocs 上下文结构和使用**: 我们的仓库将在交互会话期间大量使用 ai/workdocs/ 区域：
  - **在 ai/workdocs/active/ 下，对于每个活动任务或会话（可能按任务 ID 或分支组织），我们有文件，如**:
    - plan.md – AI 或开发人员在其中编写任务计划（这通常是 AI 列举步骤的地方，并在步骤完成或更改时更新）。
    - **context.md – 一个运行中的上下文日志，包括触发器、批准、QA 等部分。例如，它应该有**:
      - # Session Progress 总结触发的事件、待处理的批准、下一个触发器检查时间等。这基本上是正在发生的事情的索引，链接到详细信息。
      - # Automation 粘贴任何来自 dry-run 或自动化脚本的输出。
      - # QA 记录测试结果或清单结果（如 PR 提交前 make dev_check 的结果）。
      - 可能有一个 # Triggers 部分列出每个触发的触发器以及如何解决它（如加载了哪个策略文档、谁批准了它等）。
    - tasks.md – 如果需要，子任务的结构化列表，带有状态（pending/in_progress/completed）。初始规范的想法是维护步骤或触发器的待办事项列表并更新其状态，定期触发器检查可以验证这一点。
  - **我们确保指示 AI 维护这些**: 例如，在阅读说明记录进度的文档后，AI 将在 tasks.md 中添加一个条目，如"- [ ] Trigger XYZ: awaiting approval"，然后稍后将其标记为完成。
  - 当会话完成时，这些活动 workdocs 移动到 ai/workdocs/archive/<session>/... 以进行记录保存。（Phase 11 测试可能涵盖验证完成后活动目录中没有任何内容等）
  - **受众和使用**: Workdocs 不是新任务知识库的一部分（它们在会话之外不会被路由或索引）。但它们对于上下文恢复（如果 AI 断开连接）或人类监督者查看会话中发生的事情至关重要。因此，我们将保持它们轻量和事实性。
- **动态上下文管理（清理和汇总）**:
  - **随着时间的推移，活动 workdocs 可能会变大（AI 写入大量内容）。我们添加一个机制（根据修改）来自动修剪和汇总它们**:
    - 我们将检测 workdoc 更新代码（或建议 AI）为条目追加时间戳和更新计数，以便我们可以监控它变得多大。
    - **设置阈值**: 例如，如果 context.md 超过 150 行或具有 >5 个主要更新，或包含超过 30 天的内容（对于长期运行的任务），触发清理。
    - **清理过程（可能不由 AI 自发完成，而是通过计划脚本 workdocs_gc.py 完成）**:
      - 获取旧内容（例如，比最后 N 个条目更旧）并将其提供给汇总器（AI 本身可以执行此操作，或者我们可以有一个压缩它的脚本）。
      - 将汇总保存到 ai/workdocs/archive/<session>/summary_<date>.md 或 archive/summary/ 位置。
      - 在活动文件中删除或折叠这些部分，可能留下注释"[早期内容的汇总已移动到存档]"。
      - 确保删除的内容中没有任何进行中的决策所需的内容（最后 N 行的启发式或基于标记的方法应确保当前打开的任务保留）。
    - 此机制将通过 CI 或定期任务运行，而不是由 AI 代理在对话期间运行（以避免混淆）。可能在 workdoc 文件超过长度阈值时由提交钩子触发，或只是夜间运行。
    - 目标是保持 AI 处理的活动上下文可管理，同时不丢失历史（只是汇总和存档它）。
    - 我们将通过模拟长时间会话并运行汇总脚本来测试这一点。
- **任务状态跟踪**: 根据修改，我们要求 AI 在进程中进行时更新任务状态（在 tasks.md 或类似文件中）。例如，在开始时，将任务 1,2,3 列为 pending。完成任务 1 后，将其标记为完成。这提供了可见性，并帮助任何监督过程或人员知道完成了什么。它还与触发器相关：健康检查脚本可以验证没有任务意外地保持 pending（或标记为 pending 的触发器最终完成）。
- **防护栏执行和批准循环**: 我们详细说明我们部分完成的正式步骤：
  - **在防护栏指南（或 AGENTS.md 部分）中记录强制执行流程是什么。例如，"如果强制执行**: block，流程是：1) 编排器停止进一步的代码执行。2) 加载所需的文档 X、Y。3) AI 必须执行检查 A、B（这是 required_checks）。4) AI 必须通知人类或在 handoff-history.md 或 PR 中查找批准。5) 找到批准后，记录它并继续；如果被拒绝或需要回滚，执行回滚步骤并记录它们"。
  - **实现支持脚本**: 例如，guardrail_runner.py，可以模拟或实际驱动批准。例如，运行 guardrail_runner.py --event <id> 可以重播发生的事情以供审计，如规范中所述。或 guardrail_runner.py --dry-run all 以自动测试所有 block 触发器（如果它们被触发）（如测试模式）。
  - **保持审计日志**: handoff-history.md 记录所有批准和拒绝，带有时间戳和原因。可能一个全局或每个事件一个。每当触发器需要人工输入并得到解决时，防护栏代理将在此处追加条目。
  - 确保所有 block 触发器确实产生可以重播的日志是 Phase 11 测试的一部分。
  - **持续改进钩子**: 我们注意到，如果编排器或防护栏流程更改（如我们添加新触发器或更改策略），我们必须更新相关文档和映射，并运行我们的同步脚本（如 module_registry_sync.py 和 doc_node_map_sync.py）以传播更改。我们将将其纳入维护部分，说明"每当调整编排器或防护栏配置时，运行这些命令并将结果粘贴到 workdoc QA 部分"。

**原理**：Phase 10 是关于使开发过程具有交互性和弹性。AI 将有效地与我们的防护栏配对编程，并使用 workdocs 作为记忆。通过建立清晰的日志记录和状态跟踪（任务和上下文），我们使 AI 能够随着时间的推移处理复杂任务（可能它在一天结束时停止，然后第二天通过阅读 context.md 恢复以回忆发生的事情 – 这正是我们保留这些日志的原因）。动态上下文管理解决了长时间会话中上下文窗口限制的挑战，汇总较旧的信息，以便 AI 在需要时仍然可以访问它（从存档），但不会在活动内存中被它拖累。防护栏循环对于安全至关重要：即使有触发器，我们也需要正式的流程来处理某些内容被阻止的情况。通过清楚地设计它，我们确保此类事件（这些是高压力点）得到系统性处理，而不是临时处理。将所有内容记录到 workdocs 和审计文件意味着透明度 – 任何利益相关者都可以审查 AI 做了什么、它被阻止做什么以及为什么。这建立对 AI 流程的信任，并使调试更容易（如果触发器误触发，日志会显示它）。此外，要求 AI 更新状态和日志训练它更加自我记录，这是一个理想的品质。我们包含的修改 – 如清理 workdocs 和明确的状态更新 – 来自实际关注，即不断增长的上下文可能使 AI 混淆或导致失控任务。现在解决这些问题为扩展到长时间或多个并发任务而不会失去清晰度的环境奠定了基础。

**预期成果**：到 Phase 10 结束时：

- **演示交互式会话场景（可能作为测试或示例的一部分）将显示 AI 使用我们的系统完成非平凡任务。例如，AI 被分配添加涉及 DB 更改和 API 更改的新功能**:
  - 它在 plan.md 中编写计划。
  - 它查阅路由并加载所需的文档。
  - 它进行代码更改，触发器触发（DB 迁移、API 合同）。
  - 防护栏阻止 DB 迁移等待批准。AI 运行检查，在上下文中记录，请求批准（我们通过在上下文或文件中添加一行来模拟给予批准）。
  - AI 看到批准，继续运行迁移（可能在 dry-run 中），完成工作。
  - 它更新 tasks.md 状态，运行测试（可能失败或通过）。
  - 它准备一个 PR，其中 workdoc QA 片段（如 dev_check 的输出）粘贴在 context.md QA 部分中。
  - 所有这些步骤都在 ai/workdocs/active 中留下痕迹，然后我们在结束时归档它们。
  - ai/workdocs/active 目录结构和模板将建立，可能带有模板 plan.md 和 context.md，任务可以复制或使用它们初始化（预先列出部分，例如，带有每个部分占位符的 context.md 模板）。
  - **动态修剪 workdocs 将就位**: 我们可以模拟向 context.md 添加大量行，然后运行清理脚本以验证它正确归档旧内容。
  - **防护栏批准机制将被测试**: 例如，防护栏代理应检测"Approved"标记或特殊的提交状态。我们将记录人类维护者如何提供批准（可能通过编辑 handoff-history.md 以添加批准条目，或通过 PR 评论，这超出了我们的离线环境，因此可能通过编辑 AI 监控的文件或部分）。
  - 在 ai/reports/route-health.md 中，我们将开始记录有趣的指标（尽管完全进行遥测更多是在 Phase 3.5 和 Phase 11 中）。但现在，route-health 可能记录会话中触发了多少个触发器、平均批准时间等，这有助于未来的改进。
  - 总结，Phase 10 确保当 AI 代理在仓库中主动工作时，它可以以结构化方式进行，具有连续的上下文和安全网。这为最终测试/QA 阶段验证所有这些机制奠定了基础。

---

## Phase 11：测试、验证与质量保证

**目标**：为仓库模板建立严格的测试和验证框架，包括多层检查（文档一致性、能力合同测试、自动化 dry-run），并定义验证贡献的标准（PR 流程）。此阶段确保在模板（或任何后续更改）交付时，它满足所有定义的要求，并且没有结构或逻辑错误。

**范围**：Phase 11 实现三层测试计划以及贡献指南执行：

- **第 1 层**：结构和路由一致性检查 – 验证所有文档和路由链接都正确且对齐：
  - 运行 make route_lint，它将扫描所有 ROUTING.md 文件和其他文档中的语法错误、缺失字段等。
  - 运行 scripts/doc_node_map_sync.py --report 以比较实际文档和链接与 doc-node-map.yaml 索引，确保每个路由节点指向有效文档，并且每个文档都在路由中说明。
  - 运行 make registry_gen --check，这可能重建预期的文档注册表（可能从 README 或 registry.yaml），并比较以查看所有新文档是否已正确注册。例如，如果添加了新模块，它是否列在模块注册表中；如果添加了新指南文档，它是否在某处被引用。
  - 这些命令的结果应显示没有错误（意味着没有孤立文档、没有断开的链接等）。我们捕获输出并在 ai/workdocs/active/<task>/context.md#QA 中记录任何更正，以提高透明度。
  - **验收标准**："没有语法或链接错误；每个面向 AI 的文档都具有适当的 doc_role、route_role 等，与引用方式匹配；路由表与实际内容匹配"。这确保文档系统（Phase 1 和 2）是完整的。
- **第 2 层**：能力合同测试 – 验证我们能力注册表/图与实际功能元素之间的一致性，以及领域特定的合同测试：
  - **运行 make capability_index_check 和 python scripts/registry_check.py。这些将确保**:
    - ability_registry.yaml 中的每个能力在 ABILITY.md 中都有相应的条目（或部分），反之亦然，具有匹配的 graph_node_id、标签等。
    - 对于每个能力，它引用的所有方法都存在于 method_registry.yaml 中，并且编排器注册表中的映射（如将能力节点绑定到实现的 agent-graph.yaml 或 registry.yaml）是一致的。
    - 编排器中的 tools_allowed 列表与实际脚本存在等都是一致的。
  - **领域特定的合同测试**:
    - **对于数据库**: make contract_compat_check（或如果命名不同，则为 DB 特定检查）以验证 doc_agent/specs/DB_SPEC.yaml 与 db/engines/postgres/docs/DB_SPEC.yaml 匹配，并且没有发生模式漂移（如果我们模拟模式的基线）。还可能在新 DB 实例上应用所有迁移，以确保它们与模式定义对齐。
    - **对于 API**: make contract_compat_check 和 python scripts/type_contract_check.py 以验证没有破坏性 API 更改（需要基线合同进行比较）并且生成的类型与合同匹配。
  - 我们确保这些通过，或者如果有意更改（如我们更新了合同），则遵循了流程（如增加版本或获得批准）。
  - 如果有任何问题，我们记录它们并要求修复或记录的例外（可能合同被有意更改，那么必须完成基线更新以满足测试）。
  - **验收标准**："所有能力注册表测试通过，意味着实现图和文档同步。所有 API/DB 合同测试通过，意味着外部接口和数据模式没有未经批准的差异"。此外，对合同的任何更改都会触发 workdocs 计划中的更新以处理批准（我们检查如果有合同差异，plan.md 中关于批准是否存在注释）。
- **第 3 层**：自动化管道 Dry-Run 和触发器验证 – 确保自动化/触发器在测试场景中按预期运行：
  - 运行 make trigger_check 以在代表性的文件更改或事件集上模拟触发器。这应该产生输出，显示每个触发器以及任何错误（如果配置错误，如断开的正则表达式）。我们期望从读取触发器配置时没有错误。
  - 运行 python scripts/context_usage_tracker.py report --limit 10 以生成关于触发器命中或上下文使用的简短报告（假设它在测试期间记录触发器使用）。这更多是在某些使用之后；由于它是模板，我们可能必须模拟一些事件来填充此数据。如果没有，可能跳过或输出简单信息。
  - **对于新添加或更改的自动化流程**: 让 AI 或 CI 在 --dry-run 模式下运行这些流程。例如，如果我们添加了带有触发器的新部署能力，使用 --dry-run 运行它以确认它正确输出日志和风险警告。
  - 将这些 dry-run 测试的输出粘贴到 workdocs 中的 context.md#Automation，并在需要时更新 route-health.md。
  - 检查没有触发器产生意外结果（如它没有捕获应该捕获的内容，或它错误地标记了某些内容）。
  - **验收**: "所有触发器都可以无错误加载；它们的 dry-run 执行产生预期的日志记录；并且没有自动化脚本在测试模式下失败或表现异常"。基本上，管道应该看起来"健康"并准备好实际使用。
  - **注意**: 我们尚未纳入成本监控等（明确排除）。
  - **（可选）第 4 层**：部署管道 – 第 11.4 节的原始提及表明构建和部署可能稍后扩展。目前，我们跳过实际部署测试。我们注意到在这三层通过后，可以将其集成到 CI/CD 管道中进行部署，但这超出了当前范围和预算（默认情况下模板中没有成本或生产部署）。
- **PR 提交和验证流程**: 定义每个贡献必须遵守的清单（当 AI 生成 PR 时尤其重要）：
  - **在打开 PR 之前，贡献者（AI 或人类）必须运行 make dev_check，其中包含所有相关测试**: 格式化、单元测试、文档 lint、能力检查等。只有当它通过（所有测试为绿色）时，他们才能继续。
  - 还运行 make trigger_check 以确保没有未解决的触发器。
  - 他们应该收集关键输出（如 make dev_check 的摘要和任何合同检查结果）并将其粘贴到 ai/workdocs/active/<task>/context.md#QA 部分，稍后可以在 PR 描述中引用。
  - 验证所有文档都已根据更改更新（如果添加了新文档，它在路由中；如果添加了能力，ABILITY.md 已更新；如果策略更改，doc_node_map 已更新等）。
  - **按照模板编写 PR 描述（仓库将提供 PR 模板，可能在 .github/PULL_REQUEST_TEMPLATE.md 中）。描述必须包括**:
    - 更改的简要摘要。
    - 影响范围（哪些模块、功能）。
    - 验证步骤（可以链接到测试输出所在的上下文 workdoc）。
    - Workdoc 链接（例如，提及"参见 ai/workdocs/active/Task123/context.md#QA 获取测试日志"）。
    - 任何 TODO 或后续行动。
    - 如果面向 AI 的文档已更改，列出添加/删除的路由节点，以便维护者可以相应地更新任何外部索引。
  - **确保提交历史是干净的**: 遵守约定提交格式（或至少选择的提交样式），理想情况下压缩或逻辑组织提交。修改中的策略建议基于主干的开发，具有短生命周期分支，提交消息如 feat(scope): ... 等。我们强制没有大型重新格式化提交与功能更改混合（可能通过检查差异，如果它主要是空格）。
  - **批准门控**: 如果 PR 触发防护栏（如触及关键文件），必须在指定所有者批准之前不能合并。例如，如果 PR 包含生产目录中的迁移，它应该标记 DBA 等以获得批准（这可以通过 CODEOWNERS 或我们的触发器发布评论来自动化）。我们注意到"如果命中强制执行 block 的触发器，PR 应该 @ 负责人并且合并被阻止直到批准"。这很可能通过分支保护或 CI 强制执行（如需要标签）。
  - **鼓励小型、迭代的 PR**: AI 或开发人员不应捆绑太多更改。理想情况下，每个 PR 解决一个问题或模块。如果更大的更改跨越模块，将其分解为具有多个 PR 的父问题（修改提到跨模块更改的父子 PR 结构）。这符合我们一次一个模块的触发器偏好。
  - 还要求需求或问题以可验证的方式表述（以便测试人员可以检查每个验收标准）。这使得审查过程更容易，并使 AI 规划与实际目标保持一致。
  - **排除**: 承认多语言支持、成本监控或用户反馈循环等不包含在这些测试或模板范围中（与初始和修改后的规范一致）。我们可能提及它们仍然是当前 QA 之外的未来增强。

**原理**: 这个测试阶段是我们验证 Phase 1-10 中构建的所有内容实际上结合在一起的地方。没有这些检查，AI 集成系统可能会随着时间的推移而退化（遗漏文档更新或注册表条目可能会使 AI 偏离轨道，但可能直到很久以后才明显）。三层方法解决了文档完整性、功能完整性（能力和接口）和动态过程完整性（自动化顺利运行）。通过从模板阶段强制执行它们，我们确保任何使用此模板启动的项目都内置了质量。PR 流程标准化确保贡献（特别是由 AI 生成的）保持高质量和可追溯性。它实际上是我们的最后一道防护栏，确保循环中的人类可以信任更改，并且没有任何内容偷偷通过（如 AI 做出微妙的危险更改会被触发器捕获，或测试失败，或需要明确签署）。

**预期成果**: 到 Phase 11 结束时：

- **配置了完全自动化的 CI 管道（可能使用 GitHub Actions 或类似，但在模板中我们可能只提供 Makefile 和说明），运行**:
  - Linting、测试等。
  - make dev_check，它组成各种检查（我们将已更新它以包括文档 lint、触发器等）。
  - make trigger_check 以及可能任何特殊的合同检查。
  - 确保任何失败都会阻止合并。
  - 所有当前内容（文档、代码、配置）通过这些检查。我们将产生一个最终维护报告或日志，显示基线模板的"所有检查通过"。
  - 为贡献者提供的文档（可能在 doc_human/ 中的 CONTRIBUTING.md 或 AGENTS.md 中的注释）清楚地说明了 PR 要求和测试流程。
  - **项目的维护者（或扮演该角色的 AI）将有一个清晰的清单来验证审查 PR 时**:
    1. CI 是绿色的（意味着包括我们的自定义测试在内的所有测试都通过了）。
    2. PR 描述包括必需的信息并引用了 workdocs 证据。
    3. 如果适用，存在领域所有者的批准。
    4. 文档更改已包含且正确。
  - 因为我们决定不包含无关功能（如成本监控等），我们的测试严格专注于我们构建的内容，我们确认这与用户的验收一致（规范明确表示这些额外内容是超出范围的，我们保持这种方式以保持简单）。
  - 最终，Phase 11 使我们有信心宣布仓库模板实现完成且健壮，因为它将经过一系列验证，确保遵守所有早期阶段的指导原则。

---

## Phase 12：完整仓库初始化与入门

**目标**: 开发用于为特定项目初始化整个仓库模板的程序和工具。此阶段确保在应用此模板启动新项目时，收集所有必需的信息，并且模板以最少的 manual 工作适当定制。

**范围**: 在 Phase 12 中，我们处理将此仓库模板用作新项目模板的场景。关键方面：

- **创建初始化脚本/流程**: 我们将实现一个实用程序（可能在 scripts/scaffold-repo/ 或 /init/ 目录脚本中），指导用户（或 AI）将模板转换为项目：
  1. 它将提示项目特定信息：例如项目名称、描述、所需的初始模块、任何特定配置（如默认端口号等），可能还有凭据占位符等。
  2. 它可能要求用户提供初始需求文档或填写问卷（甚至可能是 AI 辅助步骤：用户提供高级描述，AI 生成一些初始文档以放置在项目中）。
  3. 根据输入，脚本将替换模板中的占位符。例如，在 README 中更改仓库名称，使用项目名称设置环境变量文件，更新任何全局标识符（如包名称）。
  4. 如果用户提供了需求文档，可能将其转换为 AI 可读的形式，并将其附加到 doc_human/ 中，并在 doc_agent/ROUTING.md 下的"项目需求"范围内引用它（实现特殊项目文档被集成的想法）。
  5. 如果指定了初始模块，运行模块脚手架来创建它们（因此 Phase 5 的脚手架由 repo-init 为每个模块调用）。
  6. 可能在初始化后运行所有检查，以确保新仓库通过 CI。
- **定义初始化结束状态**: 当满足以下条件时，认为仓库初始化已完成：
  - 基线的所有必要目录和文件都已到位，并使用项目特定信息更新（如项目名称插入到需要它的文档中，任何示例占位符已删除或确认）。
  - 文档路由完全连接（例如，如果存在某些通用占位符内容，它已被替换或删除）。
  - 在新上下文中所有 CI 测试都通过（因此模板的检查仍然成功）。
  - **基本上"只是已注册 + 准备好的文档，一切已设置，但尚未实现实际的业务逻辑"。这反映了模块初始化概念**: 我们交付一个完全连贯且测试通过的骨架，尽管它可能不提供除 hello-world 之外的任何真实功能。
  - **需要最少的 manual 后续工作**: 可能维护者只需要将仓库推送到他们选择的 VCS 并设置 CI 密钥等，但不需要修复模板问题。
- **提供 Init 目录和指南**: 作为模板的一部分，包含一个 /init/ 目录：
  - 它将包含关于如何运行初始化的使用说明（可能是 INIT_GUIDE.md 或打印的消息）。
  - 可能有一个配置文件或模板（如 project_config.yaml），可以用项目详细信息填写并在非交互模式下提供给脚本。
  - 仅在初始化期间使用的脚本或帮助文件。
  - 运行初始化后，可以安全地从项目中删除此目录（脚本可以执行此操作或指示用户删除它）。
  - **想法是分离关注点**: 模板附带额外的东西来帮助启动项目，但一旦项目启动，就不需要这些东西，因此应该清理它以避免混淆。
- **确保常见资源到位**: 模板本身将携带大部分通用内容：
  - 我们准备的所有文档（策略、路由、指南）保留。一些可能需要根据项目特定情况稍作调整（如命名）。脚本应处理这一点（例如，如果项目名称应插入到 README 中，或如果某些文档引用应包含名称）。
  - 所有基线工具和脚本保留，以便从第一天起，新项目就拥有完整的工具集（新项目可能会保留所有脚本，如 doc_node_map_sync.py 等，因为它们是持续维护的一部分）。
  - 我们假设模板的默认模块（如 api_gateway 和 DB 集成）与使用此堆栈的任何项目相关。但如果用户选择不包含某些（可能他们不想要 DB 部分），初始化过程可能允许取消选择某些功能。这可能是高级的，但至少我们可以构建事物，以便可以删除可选模块（并相应地删除文档，如如果删除 DB，删除其路由条目等）。可能现在不是自动化的，但作为注意事项提及。
- **文档**: 提供简短指南，可能在 README.md 中，说明如何使用初始化脚本执行初始项目设置。还强调，初始化后，您应该运行完整的测试套件以确保一切都是绿色的（尽管我们的脚本可能已经这样做了）。
- **对于 AI 上下文**: 初始化后，doc_agent/ROUTING.md 和其他文档可能仍会谈论模板内容。初始化脚本应确保任何特定于模板的内容（如"模板"与"项目"的引用）都已调整。并且没有任何无关信息（如这个规划规范）保留在 AI 可消费的文档中。
  - 可能将此规划规范移动到 ai/reports/archive 或删除它，因为项目现在是实际的，AI 不需要看到推测性规划。

**原理**: 此阶段解决了模板如何过渡到实际使用。没有初始化步骤，用户可能必须手动删除模板占位符或对如何开始感到困惑。通过自动化它，我们减少了人为错误（确保在将模板转换为工作仓库时不会遗漏任何关键内容）。它基本上是模板的首次应用，因此以整体方式测试所有早期阶段（如果我们的模板真正模块化且索引良好，初始化过程应该是直截了当的）。通过在使用后删除初始化脚手架，我们保持项目干净 – 这很重要，因为我们不希望留下可能被误用或 AI 稍后可能意外运行的剩余脚手架脚本。这也与安全性相关（确保没有默认凭据或密钥留在其中等）。

**预期成果**: 到 Phase 12 结束时：

- 模板仓库包含 /init/ 目录，其中包含所有入门新项目所需的材料。
- 我们已经在虚拟"项目名称 X"上测试了初始化脚本，它产生了一个新的仓库变体，通过所有测试并正确设置了文档。
- 例如，如果用户说项目"Retail API"，脚本重命名引用（可能 README "AI 集成仓库模板"变为"Retail API 开发仓库"等），并包含任何给定的特定领域信息。
- 运行后，脚本可能输出"初始化完成。您现在可以删除 /init 目录并开始开发。所有测试都通过了。"。
- 我们确保新项目的初始提交已准备好，不需要进一步的模板调整。维护者可以专注于构建功能，而不是配置管道。
- 在仓库的主 README 中清楚地记录了如何执行此初始化，以防不使用 AI 代理的人想要手动执行。
- 此时，模板不仅仅是理论上的 – 它已经验证可以轻松启动工作项目实例。

---

## Phase 13：未来增强与演进（实施后）

**目标**: 概述在核心模板实施后可以追求的额外增强和最佳实践，承认代码样式强制执行、依赖管理、高级防护栏（成本、隐私）以及扩展到不同项目规模等领域。

**范围**: 这不是初始模板的主动开发阶段，而是已识别但推迟的潜在改进的汇编，可以指导未来的维护：

- **编码标准与 Lint 增强**: 虽然我们设置了基本的 lint 检查，但我们可以进一步集成：
  - 扩展的样式指南或格式化程序，并警告不应在与功能更改相同的 PR 中进行大规模重新格式化（以保持差异干净）。
  - 可能配置自动格式化工具（Python 的 Black、前端的 Prettier），但确保贡献者指南说明要分离仅格式化的更改。
- **依赖和供应链管理**:
  - 实现依赖锁定（如使用 Python 的 pip-tools 来锁定版本），以便构建是确定性的。
  - 维护许可证允许列表（避免拉入未知许可的代码）。
  - 为依赖更改引入触发器，例如如果 requirements.txt 更改，运行安全审计工具或需要审查（未来想法）。
  - 在 AI 协助下按计划自动更新依赖（例如，一个机器人升级版本，然后触发测试）。
- **秘密和配置安全**:
  - 强制执行不提交纯文本秘密（设置 git pre-commit 或 CI 中的扫描以查找 API 密钥等模式）。
  - 提供使用环境变量或 Vault 集成来管理秘密的模式，在安全指南中记录。
  - 可能为 CI 集成秘密扫描工具。
- **AI 成本和配额防护栏**:
  - **随着项目可能演变为使用 AI 服务（如调用外部 API），定义预算并实现防护栏**:
    - 例如，一个触发器计算 AI 尝试昂贵操作的次数，如果超过阈值，强制不同的策略或停止以防止成本超支。
    - 这可能与 context_usage_tracker 相关，以监控使用的令牌等。（虽然不会立即实现，但我们为未来记录它）。
- **数据隐私最小化**:
  - 如果处理敏感数据，通过设计确保不必要地记录或存储 PII。
  - 如果可能出现 PII，可能要求匿名化或编辑日志。
  - 如果需要，有一个关于数据隐私的策略文档，AI 可以阅读并遵循（现在不包括，但如果项目处理用户数据，可能会添加）。
- **增强的交互工具**:
  - 开发用于可视化关系的实用程序，例如，输出高级与低级能力图的脚本（以便维护者可以轻松看到大局）。
  - 用于大规模模拟触发器和防护栏的工具（可能运行场景生成器通过所有触发器以查看是否有任何冲突）。
  - **分析交叉影响的工具**: 如果文件或 API 更改，列出可能需要更新的文档或注册表条目。可能像 grep 引用一样简单，或者像在图中跟踪依赖关系一样复杂。
- **项目可扩展性**:
  - 在中等项目上验证模板后，考虑为可能不需要所有组件的小项目制作精简版本（可能只有一个模块，没有 DB 或更简单的文档）。这可能是子集模板或初始化脚本中的标志（例如，--minimal 模式，仅设置核心，没有 DB/API）。
  - **多语言支持**: 如果需要扩展到其他编程语言或框架（如 Node.js 模块或多语言仓库），考虑如何纳入这一点。可能有单独的模板，或者以语言无关的方式设计文档和编排，以便可以重用。
- **监控与反馈**:
  - 引入 AI 调用的成本监控和性能指标聚合器（可能稍后在实际使用观察时集成）。
  - 可能纳入用户反馈循环，其中捕获用户测试结果或反馈并反馈到 workdoc 或待办事项（模板尚未涵盖这一点，但作为增强，可以添加一个机制，让 AI 从文件或问题跟踪器获取用户错误报告并对其采取行动）。
- **持续改进流程**:
  - 建议添加到项目的 README 或维护文档中，计划随着项目成熟而迭代增强这些方面（可能通过维护冲刺等）。
  - 强调任何此类增强还应遵循相同的原则（文档化、测试等）。

**原理**: 列出未来增强作为维护者的路线图。它确保虽然我们有一个强大的起点，但我们意识到其边界并准备在未来解决它们，而不会将它们混合到初始交付物中（以避免现在复杂性蔓延）。代码样式等项目是次要的，但有助于维护长期健康。其他如成本和反馈循环取决于实际项目上下文，因此被推迟。将它们包含在内部计划中强调我们已经考虑过它们并有意识地推迟 – 这本身就是彻底规划的标志。此外，随着 AI 工具的发展，我们可能会纳入新的最佳实践（例如新的防护栏框架、更好的上下文管理算法） – 拥有一个承认这一点的部分鼓励未来的维护者（可能是另一个 AI 或团队）在进行升级时继续遵守模板的哲学。

**预期成果**: Phase 13 本身不会在仓库中产生直接更改（因为它超出当前范围），但作为规划规范：

- README.md 或维护文档可能包含一个简短的部分"未来工作"，总结这些要点以提高透明度（特别是像成本监控现在超出范围以设置期望这样的事情）。
- 团队有一个清晰的增强列表，一旦当前系统稳定，可以承担这些增强，可能记录为待办事项或跟踪器中的问题。
- AI（如果继续协助）可以被此列表指导，不要过早尝试实现这些，而是将它们视为可选或下一阶段任务。
- 本质上，我们确保模板不是死胡同，而是可以适应出现的额外需求的基础。
