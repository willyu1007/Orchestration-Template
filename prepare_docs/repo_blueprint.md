# AI友好的基础设置仓库模板蓝图

> 我们不是要建设某个具体可运行项目，而是完善提高AI编号效率和准确性的基础建设。后续可以作为AI深度参与的项目开发的模板


本蓝图概述了一个为高效且可控的 AI 驱动开发而设计的仓库模板。它将深度 AI 参与整合到软件生命周期中，遵循四个核心原则：智能编排、AI 友好性、模块化开发和自动化维护。每个原则都得到特定机制和约定的支持，确保 AI 代理能够有效地在编码任务中协作，同时开发者保持监督和质量。以下章节详细说明这些原则以及它们如何塑造仓库的设计。

- 建设目标

  - 快速加载所需知识
  - 使用工具处理问题
  - 自动化
    - 上下文记忆
    - 1
  - 一致性
    - 基础单元都需要注册
    - 严格遵循运行规范


- 解决方案

## 1. 模块化开发

模块化开发是一个原则，确保仓库被结构化为定义良好、松散耦合的模块，使人类开发者和AI代理都能在清晰的边界内工作。
每个模块维护其自身的配置、策略、工作记录、和代码实现，并维护可用的功能和知识路由。通过限制任何单个操作的范围来提高AI上下文管理效率。

### 1.1 概念说明（core concepts）
和模块相关的概念主要有三个： module_level（层级）、module_type（类型）、module_entity（实例）
-  模块实例是面向业务的，是实际开发的唯一载体，前端/后端/逻辑的实现都需要对应到模块实例。
-  模块类型是用来描述业务流和数据流，类型间的调用/依赖关系，组成图结构
-  模块层级和类型是解耦的，层级描述实例的组成/包含关系，构成关系树


### 1.2 信息维护（info maintain）

SSOT

- 新模块注册
- 新类型注册

- 内容修改
- 层级维护


### 1.3 工作记录（AI workdocs）

每个模块实例都需要维护工作记录，骨架结构形如
```
workdocs/
├── AGENTS.md              # This file
├── active/                # Current work
│   ├── task-1/
│   │   ├── task-1-plan.md
│   │   ├── task-1-context.md
│   │   ├── task-1-errors.md
│   │   └── task-1-tasks.md
│   │   └── task-1-details.md
│   └── task-2/
│       └── ...
└── archive/               # Completed work (optional)
    ├── summary/
    ├── old_tasks/
        └── ...
```


workdocs/active/


### 1.4 体系协同（collaboration）
所有的功能/知识/触发器，都需要挂在到具体的模块实例下
- 知识路由体系

- 能力路由体系

- 运行策略
- 触发器体系




有了上述结构，AI 编排周期的工作方式如下：AI 获取任务，查阅顶级 `ROUTING.md` 以定位相关上下文（并读取 `AGENTS.md` 中的任何必需策略），从能力注册表中识别合适的高层能力，然后执行它。编排器使用一个将上下文 → 策略 → 能力映射的决策流程：

- **上下文查找**：通过路由文件中的 context_routes（范围/主题/时机）找到正确的文档。
- **策略检查**：在继续之前，为该上下文加载任何必需的护栏或策略（来自 `AGENTS.md`）。
- **选择能力**：选择与任务意图匹配的高层能力（工作流/代理）（能力注册表按域和意图组织），并检查是否允许（只有稳定的能力对编排器可用——参见维护部分）。
- **执行计划**：运行高层能力，它按照其步骤中定义的方式编排低层方法调用（脚本、API 调用）。编排器不会微观管理低层调用；它委托给工作流/代理定义，这确保了多个步骤的一致执行。
- **迭代或移交**：如果任务需要多个步骤或子任务，编排器可能会循环返回以获取更多上下文或能力用于下一步（始终遵循路由和策略指导）。在某些情况下，它可能会移交给专门的子代理（例如，用于一系列数据库操作的"DatabaseOps"代理），如能力图中定义的那样。


--- 

## 2. 能力路由

### 概念说明（core concepts）

我们希望AI的规划尽可能保持在抽象级别上运行，而不会会底层细节淹没。项目通过维护一个双层的能力系统，从而保持编排的可管理型。
- 低层能力：细粒度的操作，如运行脚本或调用API。通常代表原子操作，允许由多个实现。
- 高层能力：由低层步骤组成的高级任务或工作流，会优先暴露给编排器进行规划。

低层能力和高层能力都需要进行注册（模板会提供能力相关的注册和修改脚手架，以保证格式的规范）。能力的注册信息会存入统一的文件路径（区分低层和高层），能力实现也会统一存放。
一般而言，每个模块实例会维护一个，高层能力的路由。这些路由文档命名统一为`ABILITY.md`。所有的`ABILITY.md`只提供文件路径和使用情况说明。注册机制和所有的`ABILITY.md`文档共同组成了能力路由。

### 编排过程

- 模块实例的功能开发
  1. 阅读模块实例目录下的`ABILITY.md`；
  2. 查看`ABILITY.md`允许使用的高层能力以及**应用情景**说明；
     - 如发现有可以使用的高层能力，依据路由跳转至能力注册文档，检验是否要求、输入、输出等是否满足条件。如满足条件直接调用，如不满足退回`ABILITY.md`继续查询（高层能力有`maturity`字段，优先调用字段为`stable`的能力）
     - 如没有可以使用的高层能力，进入步骤三
  3. 检索`ABILITY.md`包含的低层能力以及**功能描述**，决定是否调用；
  4. 将选择能力的决策过程记录到工作上下文（`workdocs/active/<task>/details.md`）中
     - 如调用了高层能力，记录调用原因、能力`name`和`maturity`，以及执行结果
     - 如调用了低层能力，记录调用原因、能力`name`、以及执行结果。 
- 多个模块示例的联调



### 注册和维护


---

## 3. 知识路由

---


## 4. 运行策略

---

## 5. 触发器


### 命中检验（trigger）

### 规范检验（pre-tool-use）

### 改动处理（post-tool-use）




---


## 6. 脚手架

### 6.1 数据库操作

### 6.2 API接口管理


--- 

## 7. 外挂知识

### prompts

### patterns

### 编排器
