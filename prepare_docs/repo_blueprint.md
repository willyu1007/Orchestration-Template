# AI友好的基础设置仓库模板蓝图

> 我们不是要建设某个具体可运行项目，而是完善提高AI编号效率和准确性的基础建设。后续可以作为AI深度参与的项目开发的模板


本蓝图概述了一个为高效且可控的 AI 驱动开发而设计的仓库模板。它将深度 AI 参与整合到软件生命周期中，遵循四个核心原则：智能编排、AI 友好性、模块化开发和自动化维护。每个原则都得到特定机制和约定的支持，确保 AI 代理能够有效地在编码任务中协作，同时开发者保持监督和质量。以下章节详细说明这些原则以及它们如何塑造仓库的设计。

- 建设目标

  - 快速加载所需知识
  - 使用工具处理问题
  - 自动化
    - 上下文记忆
    - 1
  - 一致性
    - 基础单元都需要注册
    - 严格遵循运行规范


- 解决方案

## 1. 模块化开发

模块化开发是一个原则，确保仓库被结构化为定义良好、松散耦合的模块，使人类开发者和AI代理都能在清晰的边界内工作。
每个模块维护其自身的配置、策略、工作记录、和代码实现，并维护可用的功能和知识路由。通过限制任何单个操作的范围来提高AI上下文管理效率。

### 1.1 概念说明（core concepts）
和模块相关的概念主要有三个： module_level（层级）、module_type（类型）、module_entity（实例）
-  模块实例是面向业务的，是实际开发的唯一载体，前端/后端/逻辑的实现都需要对应到模块实例。
-  模块类型是用来描述业务流和数据流，类型间的调用/依赖关系，组成图结构
-  模块层级和类型是解耦的，层级描述实例的组成/包含关系，构成关系树


### 1.2 信息维护（info maintain）

SSOT

- 新模块注册
- 新类型注册

- 内容修改
- 层级维护


### 1.3 工作记录（AI workdocs）

每个模块实例都需要维护工作记录，骨架结构形如
```
workdocs/
├── AGENTS.md              # This file
├── active/                # Current work
│   ├── task-1/
│   │   ├── task-1-plan.md
│   │   ├── task-1-context.md
│   │   ├── task-1-errors.md
│   │   └── task-1-tasks.md
│   │   └── task-1-details.md
│   └── task-2/
│       └── ...
└── archive/               # Completed work (optional)
    ├── summary/
    ├── old_tasks/
        └── ...
```


workdocs/active/


### 1.4 体系协同（collaboration）
所有的功能/知识/触发器，都需要挂在到具体的模块实例下
- 知识路由体系

- 能力路由体系

- 运行策略
- 触发器体系




有了上述结构，AI 编排周期的工作方式如下：AI 获取任务，查阅顶级 `ROUTING.md` 以定位相关上下文（并读取 `AGENTS.md` 中的任何必需策略），从能力注册表中识别合适的高层能力，然后执行它。编排器使用一个将上下文 → 策略 → 能力映射的决策流程：

- **上下文查找**：通过路由文件中的 context_routes（范围/主题/时机）找到正确的文档。
- **策略检查**：在继续之前，为该上下文加载任何必需的护栏或策略（来自 `AGENTS.md`）。
- **选择能力**：选择与任务意图匹配的高层能力（工作流/代理）（能力注册表按域和意图组织），并检查是否允许（只有稳定的能力对编排器可用——参见维护部分）。
- **执行计划**：运行高层能力，它按照其步骤中定义的方式编排低层方法调用（脚本、API 调用）。编排器不会微观管理低层调用；它委托给工作流/代理定义，这确保了多个步骤的一致执行。
- **迭代或移交**：如果任务需要多个步骤或子任务，编排器可能会循环返回以获取更多上下文或能力用于下一步（始终遵循路由和策略指导）。在某些情况下，它可能会移交给专门的子代理（例如，用于一系列数据库操作的"DatabaseOps"代理），如能力图中定义的那样。


--- 

## 2. 能力路由

### 概念说明（core concepts）

我们希望AI的规划尽可能保持在抽象级别上运行，而不会被底层细节淹没。项目通过维护一个双层的能力系统，从而保持编排的可管理型。
- 低层能力：细粒度的操作，如运行脚本或调用API。通常代表原子操作，允许由多个实现。
- 高层能力：由低层步骤组成的高级任务或工作流，会优先暴露给编排器进行规划。

低层能力和高层能力都需要进行注册（模板会提供能力相关的注册和修改脚手架，以保证格式的规范）。能力的注册信息会存入统一的文件路径（区分低层和高层），能力实现也会统一存放。
每个模块实例通畅会维护自身的高层能力路由，项目会额外维护一份路由作为入口，这些路由文档命名统一为`ABILITY.md`。所有的`ABILITY.md`只提供文件路径和使用情况说明。注册机制和所有的`ABILITY.md`文档共同组成了能力路由。

### 编排过程

- 模块实例的功能开发
  1. 阅读模块实例目录下的`ABILITY.md`；
  2. 查看`ABILITY.md`允许使用的高层能力以及**应用情景**说明；
     - 如发现有可以使用的高层能力，依据路由跳转至能力注册文档，检验是否要求、输入、输出等是否满足条件。如满足条件直接调用，如不满足退回`ABILITY.md`继续查询（高层能力有`maturity`字段，优先调用字段为`stable`的能力）
     - 如没有可以使用的高层能力，进入步骤三
  3. 检索`ABILITY.md`包含的低层能力以及**功能描述**，决定是否调用；
  4. 将选择能力的决策过程记录到工作上下文（`workdocs/active/<task>/details.md`）中
     - 如调用了高层能力，记录调用原因、能力`name`和`maturity`，以及执行结果
     - 如调用了低层能力，记录调用原因、能力`name`、以及执行结果。 
- 多个模块示例的联调



### 注册和维护


---

## 3. 知识路由

### 3.1 概念说明

为了减少AI在检索文档的不确定性，提高获取知识的效率和密度。我们构建了多级文档路由系统，旨在提高任务规划的效率和可靠性，给予AI明确的指导至相关信息。知识路由的两个主要目标有两个：
- 将适当的知识告知代码大模型：给AI的知识既要准确，同时也要精简。
- 路径引导符合大模型的工作模式：要发挥AI的任务编排体系的灵活性。

为达成上述两个目标，文档路由采用三层结构：范围 → 主题 → 时机。对于每个组合，路由条目将指定目标文档 —— AI应在该情况下加载的实际文档链接。这类似于图书馆的目录表索引：告诉AI应该查阅图书馆的哪个部分找哪些书以获取所需知识。

每个模块实例通畅会维护自身的知识路由，项目会额外维护一份路由作为入口，这些路由文档命名统一为`ROUTING.md`。所有的`ROUTING.md`都会按照既定的格式编写路由`content_route`，通过分层结构指向知识文档。

### 3.2 分层指南

知识路由按照高级领域（scope）、特定主题（topic）、特定情形（when），将AI任务编排所需的上下文映射到分层体系中，以保障AI指导对于任何软定义的任务应该加载哪些上下文。

- scope：生命周期或跨模块的工作场景，描述路由节点覆盖的"责任域"或"工作阶段"，与任务编排保持顶层一致性
- topic：具体职责或能力单元，聚焦"要处理什么类型的问题/任务"。topic将广义责任域进一步拆分成可路由的能力单元
- when：在什么情境下需要加载"这一组文档/资源"；一句话说明场景与目标，让智能体根据具体需求匹配合适的文档集合

### 3.3 基本规则



- 不包含的文档：
  - 面向人类的文档

### 3.4 路由维护

- 注册
- 模块化开发




- **澄清路由的注册范围**：我们确认只有路由文件本身及其直接叶节点在 context_routes 索引中明确列出。我们不会尝试注册每个子节或示例文件——叶文档内的子节应由 AI 根据需要逐步发现，而不是在路由中枚举（以避免索引过载）。面向人类的文档完全保留在路由索引之外。这种方法使路由表保持专注和可维护。
- **实现路由前置元数据和元数据**：每个 ROUTING.md 将包含一个前置元数据（带有 doc_kind: router、audience 等）和标准化结构。内容可能是将 scope/topic/when 映射到 target_docs 的表格或列表。我们还将维护一个中央 YAML 文件（例如 doc_agent/orchestration/doc-node-map.yaml），作为所有文档节点及其角色的权威注册表。此映射将帮助自动化工具验证路由文件和实际文档之间的一致性。
- **遵守分层路由责任**：顶级 ROUTING.md 专注于广泛的"读什么/去哪里"方向，而较低级别的可能包含更多特定上下文的说明或链接到快速入门和指南。我们避免在多个级别重复内容；每个 ROUTING.md 仅指向下一级别或最终文档，而不是重复这些文档的细节。这使每个路由文件保持简洁，整体导航清晰。
- **为核心主题创建初始路由条目**：例如，根 ROUTING.md 可能有一个条目，如 Scope: "文档与标准" – Topic: "仓库约定" – When: "设置或更新文档"，指向文档指南或标准（可能在 doc_agent/guide/ 目录中）。另一个例子：Scope: "执行 – 数据库" – Topic: "模式更改" – When: "修改数据库模式或迁移"指向 DB 子系统的文档（如 DB 规范或迁移指南）。同样，执行 – API 条目将路由到 API 网关和合同文档。我们将根据后续阶段开发的内容填充这些路由（Phase 6 用于 DB，Phase 7 用于 API 等），但占位符和结构将在现在建立。
- **设置管理路由的工具**：我们计划实现或配置脚本来验证和刷新路由索引。例如，doc_node_map_sync 脚本可以解析所有 ROUTING.md 文件以构建 doc-node-map.yaml，反之亦然，确保没有死链接或孤立文档。将引入 make route_lint 命令来捕获错误，如缺失的路由目标或引用文档中不一致的前置元数据。



---


## 4. 运行策略

标准化文档格式、命名约定、目录结构，并确保文档针对 AI 消费进行了优化

- **定义文档角色和受众**：所有文档必须清楚地标明是面向 AI 还是面向人类读者（在前置元数据中），并遵守特定角色的指导原则。面向 AI 的文档（如路由指南、代理策略、能力索引等）应保持简洁（通常 <150 行）且高度结构化，而面向人类的文档（例如 README）没有严格的长度限制，但应标明 AI 可以忽略它们。
- **执行格式和样式规则**：所有文档使用 UTF-8 编码和 Markdown 格式。所有内容生成和编辑（除非用户特别要求）应为英文。避免非结构化散文或过度使用表情符号/符号（简单的状态图标除外）。
- **建立文件、目录和代码的命名约定**：例如，文档文件使用 kebab-case（例如 data-spec.md），环境常量使用 UPPER_SNAKE_CASE，Python 变量/函数使用 camelCase，类使用 PascalCase，数据库实体使用 snake_case。标准命名模式可防止混淆和冲突（例如，使用 <topic>-<type> 或 <topic>.<type> 后缀以提高清晰度）。
- **组织文档目录**：所有面向 AI 的文档将位于专用路径下，如 doc_agent/（用于 AI 特定知识）或模块特定的 doc/ 子文件夹中，而面向人类的文档（除高级 README 外）将位于 doc_human/ 下或明确分离，以避免混合上下文。进行中的上下文笔记将位于 ai/workdocs/（包含 active 和 archive 子文件夹）中，内部报告位于 ai/reports/，确保 AI 不会意外加载无关的人类导向或归档内容。
- **为所有 AI 可读文档准备前置元数据模式**：每个此类文件必须以标准化的 YAML 前置元数据开头，声明字段如 audience（必须是 "ai" 或 "human"，不能两者兼有）、purpose、doc_role（例如 quickstart、guide、spec、contract 等）、doc_kind（例如 router、agent_policy、capability_index 等），以及元数据如 updated_at 和所有权标签。叶节点文档（路由指向的最终内容文档）应在前置元数据中包含 route_role: leaf，以标记它们为文档路由树中的端点。我们还将引入模式文件（例如 spec/front-matter.schema.yaml 等）来定义这些前置元数据结构，并启用文档格式验证。
- **在文档设计中实现"渐进式披露"原则**：顶级 AI 入口文档（如 ROUTING.md）将保持极其轻量——仅列出基本角色、导航链接或常用命令，没有冗长的背景文本。更深入的详细信息被推迟到较低级别的指南或规范中，通过链接引用，因此 AI 只读取当前任务所需的内容。高级文档回答"做什么，在哪里找到它"；中级文档作为特定任务的手册或策略；低级文档提供完整的技术细节或示例。这种结构帮助 AI 最初加载最少的内容，然后根据需要逐步获取更详细的文档（避免令牌溢出）。我们将把这种渐进式加载方法编入文档编写的最佳实践（例如，在文档中添加关于下一步应阅读哪个文档或部分以获得更深入信息的注释）。
- **确定要在仓库根目录和模块中存在的核心文档文件**：按照约定，每个作为导航中心的目录将包含一个 ROUTING.md（用于导航），如果该目录包含 AI 可执行组件，则可能包含一个 ABILITY.md（原名 CAPABILITIES.md，用于能力索引）和一个 AGENTS.md（用于本地代理策略）。但是，根据修订后的共识，仓库的根目录将保存主要的 AGENTS.md，作为整个项目的单一全局策略和防护栏入口（整合全局规则）。模块目录如果有自己的执行逻辑，可以有自己的 AGENTS.md，但要求在每个子目录中都有所有三个文件的要求已放宽，以减少冗余。如果目录纯粹用于文档或不托管活动代理，它可以省略本地 AGENTS.md 或 ABILITY.md，更高级别的路由将简单地链接到该模块中的相关文档。



---

## 5. 触发器


### 命中检验（trigger）

### 规范检验（pre-tool-use）

### 改动处理（post-tool-use）




---


## 6. 脚手架

### 6.1 数据库操作

### 6.2 API接口管理


--- 

## 7. 外挂知识

### prompts

### patterns

### 编排器
