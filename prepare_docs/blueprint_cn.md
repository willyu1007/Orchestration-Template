# 深度 AI 集成仓库模板蓝图

本蓝图概述了一个为高效且可控的 AI 驱动开发而设计的仓库模板。它将深度 AI 参与整合到软件生命周期中，遵循四个核心原则：智能编排、AI 友好性、模块化开发和自动化维护。每个原则都得到特定机制和约定的支持，确保 AI 代理能够有效地在编码任务中协作，同时开发者保持监督和质量。以下章节详细说明这些原则以及它们如何塑造仓库的设计。

## 智能编排

智能编排意味着 AI 编排代理能够以受控的方式规划和执行开发任务，使用对项目的结构化理解。仓库提供了一个定义良好的 AI 编排层，由文档化的路由、能力图、触发器和护栏组成，指导 AI 的决策制定。

### 文档与上下文路由

多级文档路由系统在正确的时间将 AI 引导到正确的信息。每个目录可以包含一个 `ROUTING.md` 文件，为该上下文定义分层导航结构（范围 → 主题 → 时机）。这就像一个目录表，告诉 AI"去这个部分查找 X，然后去那个部分查找 Y"，一直到特定文档（叶子节点）。例如，根 `ROUTING.md` 可能有一个"数据库变更"的范围，一个"迁移"的主题，以及一个"应用新迁移时"的时机条目，指向指南或规范文档。这确保 AI 编排器在行动之前能够将任务的上下文与相关文档匹配。AI 首先加载适当的 `ROUTING.md`，找到匹配的范围/主题/时机条目，然后跟随链接到目标文档。如果该主题有特殊策略，编排器还会根据需要加载同级 `AGENTS.md`（策略）或能力索引。这样，AI 始终以正确的任务指导来定位自己。

### 能力图与双层能力

除了文档之外，AI 编排器依赖于一个定义可用操作（能力）及其组合方式的能力图。我们实现了一个双层能力系统，以保持编排的可管理性。

- **低层能力（方法）**：细粒度的操作，如运行脚本或调用 API，使用 `base.<domain>.<action>` 这样的名称标识（例如 `base.db.migrate`）。它们代表原子操作（脚本、外部服务调用等），并且同一操作可以有多个实现（例如查询数据库的不同方式）。

- **高层能力（复合工作流/代理）**：由低层步骤组成的高级任务或工作流，命名为 `able.<domain>.<intent>`（例如 `able.db.apply_all_migrations`）。只有高层能力暴露给编排器进行规划；编排器将选择一个高层工作流/代理来执行请求，而该高层能力知道要调用哪些低层步骤。

这种分离意味着 AI 的规划在抽象级别上运行（例如"应用所有迁移"作为一个步骤），而不会被底层细节所淹没，同时仍然允许低层方法的灵活实现。每个能力都在中央索引中注册（例如高层为 `ability_registry`，低层为 `method_registry`），包含元数据，如唯一 ID、类型（工作流或代理 vs. 脚本或 API）、输入/输出、所有者模块等。通过为每个能力标记 `owner_id`（负责的模块），我们确保一个模块拥有每个高级能力，防止 AI 在单个任务中跨越模块边界。

### 编排过程

有了上述结构，AI 编排周期的工作方式如下：AI 获取任务，查阅顶级 `ROUTING.md` 以定位相关上下文（并读取 `AGENTS.md` 中的任何必需策略），从能力注册表中识别合适的高层能力，然后执行它。编排器使用一个将上下文 → 策略 → 能力映射的决策流程：

- **上下文查找**：通过路由文件中的 context_routes（范围/主题/时机）找到正确的文档。
- **策略检查**：在继续之前，为该上下文加载任何必需的护栏或策略（来自 `AGENTS.md`）。
- **选择能力**：选择与任务意图匹配的高层能力（工作流/代理）（能力注册表按域和意图组织），并检查是否允许（只有稳定的能力对编排器可用——参见维护部分）。
- **执行计划**：运行高层能力，它按照其步骤中定义的方式编排低层方法调用（脚本、API 调用）。编排器不会微观管理低层调用；它委托给工作流/代理定义，这确保了多个步骤的一致执行。
- **迭代或移交**：如果任务需要多个步骤或子任务，编排器可能会循环返回以获取更多上下文或能力用于下一步（始终遵循路由和策略指导）。在某些情况下，它可能会移交给专门的子代理（例如，用于一系列数据库操作的"DatabaseOps"代理），如能力图中定义的那样。

### 触发器和护栏

为了保持编排的安全性和可控性，模板集成了一个触发器和护栏系统。触发器是事件驱动的检查（例如"数据库迁移文件被修改"），护栏是策略强制执行（例如"生产数据库迁移需要手动批准"）。这些不被视为普通能力，而是编排器在规划和执行期间查阅的控制层。

每个高层能力可以有一个关联的安全配置文件，列出适用于它的触发器或护栏。例如，能力 `able.db.apply_all_migrations` 可能有一个安全配置文件，引用触发器 `db-migration` 和护栏 `require_approval_for_prod`。在运行时，如果编排器即将执行该能力，系统将检查触发器的条件和执行级别。我们为触发器分配明确的优先级（例如 P0 表示最高优先级），因此如果多个触发器触发，最重要的规则首先处理。像 `db-migration` 这样的 P0 触发器可能被配置为阻止操作，直到某些检查通过或人类批准。编排器将记录所有被激活的触发器（即使那些由于优先级较低而未执行的），以便审计。能力和触发器/护栏之间的这种双向链接确保每当 AI 即将执行风险操作时，相关的安全检查和批准会自动生效，并且任何策略更改都易于从双方追溯。

### 说明性示例

假设 AI 需要更新数据库模式。编排器查阅路由系统，在 `ROUTING.md` 中找到数据库范围和迁移主题，引导它到数据库迁移指南（叶子文档），并注意到需要特殊策略。它加载全局 `AGENTS.md`（策略），其中概述了诸如要求生产变更批准等规则。接下来，编排器查找此任务的高层能力，并在注册表中找到 `able.db.apply_all_migrations`。该能力的安全配置文件指示触发器 `db-migration`，优先级为 P0，执行级别为"阻止"。在尝试运行它时，触发器条件（检测到迁移脚本更改）得到满足，因此编排器暂停执行并加载指定的策略文档（可能是 `AGENTS.md` 中关于数据库迁移过程的条目）。它还运行必需的检查（如迁移的试运行），如触发器配置中列出的那样。只有在检查通过并记录了人类批准（根据护栏 `require_approval_for_prod`）后，编排器才会继续执行 `able.db.apply_all_migrations` 的步骤。这些步骤涉及调用低层方法，如为每个迁移调用 `base.db.migrate`，以及调用 `base.db.check_health` 以验证数据库状态。在整个过程中，AI 将其操作和发现记录在工作日志（workdoc）中，如果任何步骤失败或策略阻止，该事件会被记录供开发者审查。这个场景展示了智能编排如何将 AI 在执行常规步骤时的自主性与确保关键操作监督的安全互锁相结合。

## AI 友好性

AI 友好性是关于设计仓库的内容和结构，使其易于被 AI 代理理解和导航。所有文档、代码结构和约定都经过优化，以便大型语言模型（代码助手）能够解析它们，保持在上下文限制内，并准确检索所需内容而不会混淆。关键机制包括标准化文档格式、AI 与人类内容的清晰分离，以及信息的渐进式披露。

### AI 标准化文档

模板强制执行严格的文档标准，以使 AI 的信息消费可靠。每个面向 AI 的文档都包含一个 YAML 前置元数据，指定元数据，如 `audience: ai`、`purpose`、`doc_role` 和 `doc_kind`（例如 router、agent_policy、ability_index、guide 等）。这告诉 AI 文档的用途以及何时使用它。例如，`ROUTING.md` 文件具有 `doc_kind: router` 并且仅包含导航信息，而 `AGENTS.md` 将具有 `doc_kind: agent_policy` 并概述该范围内 AI 的规则和边界。所有面向 AI 的文档都保持简短和结构化——内容较多的通常少于 150 行——以适应提示限制并实现快速扫描。它们使用简单、声明性的语言（清单、表格、要点）而不是冗长的散文，避免歧义。此外，命名约定是一致的：关键文件使用固定名称（例如，`README.md` 用于人类概览，`ROUTING.md`/`AGENTS.md`/`ABILITY.md` 用于 AI 入口点），以防止 AI 遗漏它们。临时或特定上下文的文件被明确标记（例如后缀 `_temp` 并放置在 `temp/` 目录中），以便 AI 知道忽略或以不同方式处理它们。

### "三大支柱"文档

我们建立了三种核心文档类型，它们构成任何文件夹中 AI 指导的支柱：路由文件、代理策略文件和能力索引文件。如前所述，每个包含 AI 可执行逻辑的目录都将有一个 `ROUTING.md` 来指导上下文查找，一个 `AGENTS.md` 来定义本地策略/护栏，以及一个 `ABILITY.md`（以前名为 `CAPABILITIES.md`）来索引该范围内提供的能力/工具。这个三元组充当 AI 和代码库知识之间的规范接口：

- **ROUTING.md** – 告诉 AI 在该模块或上下文中"在哪里找到信息"，用于各种主题和场景（它列出下一步文档而不是详细信息）。
- **AGENTS.md** – 告诉 AI"你在这里被允许或应该做什么"，包括任何约束、所需的批准或模块的特殊程序。它本质上充当该区域的本地规则手册或"护栏文档"。
- **ABILITY.md** – 呈现"你在这里可以做什么"，即该模块中 AI 可以调用的可用操作或入口点（脚本、函数、API）的目录。它列出每个能力及其标识符、类型以及输入/输出或触发器的描述，为 AI 提供可能操作的索引。（在内部，这对应于机器可读的能力注册表，但 `ABILITY.md` 是面向 AI 的摘要。）

按照约定，这些文件在整个仓库中具有统一的结构和命名，因此 AI 始终可以推断它们的存在。一致的命名（"AGENTS"、"ABILITY"）避免了混淆——例如，术语"capabilities"被替换为"abilities"，以区分低级能力与更高级的 AI 代理（也可以称为能力）。术语的这种清晰性有助于 AI 正确解释仓库。

### 渐进式披露原则

为了保持上下文的完整性，不让 AI 被过多信息淹没，文档采用渐进式披露（渐进式）策略进行组织。AI 应该根据需要以小的、相关的块读取信息，而不是加载整个手册。路由层次结构通过缩小相关内容来促进这一点，但即使在文档内部，我们也鼓励分层方法：

- 高级"快速入门"或摘要文档仅提供任务的基本步骤或信息。AI 将首先尝试通过阅读这些来完成任务。
- 如果需要更多详细信息，AI 可以跟随链接或引用到该主题的更深入的指南或规范文档。每一层都指向下一层，但在需要之前不会加载任何内容。
- AI 在打开文档时总是检查文档的前置元数据，以确保它是预期的类型/受众；如果结果证明是错误的上下文，AI 知道回溯到路由并找到正确的文档。
- 我们明确指示 AI 在不需要时不要转储或读取大型文件——相反，它应该只检索解决其当前子任务的部分。这不仅节省了令牌使用，还保持 AI 专注并防止重要上下文的稀释。
- 在阅读时，AI 将其已消费的内容（以及任何关键结论）记录到工作日志（在 `ai/workdocs/` 下）作为面包屑。这样，如果任务被中断或传递给不同的代理/人类，上下文会保存在 workdoc 中。workdocs 捕获 AI 的进度和决策，可以稍后审查或恢复，而无需 AI 从头重新阅读所有内容。

在实践中，AI 代理可能从模块的 `ROUTING.md` 开始，导航到相关的快速入门（可能是几十行简洁的说明），然后仅在需要时打开详细指南以了解它正在实现的特定功能。同时，它在 workdoc 中记录"阅读快速入门 X，理解了 Y"以维护状态。通过强制执行这种增量阅读工作流，我们确保 AI 的上下文窗口得到有效使用，并保持与当前任务相关。

### AI 与人类关注点的分离

AI 友好性的另一个方面是清楚地分离面向 AI 与面向人类的文档（甚至目录空间）。我们维护并行文档树：例如，`doc_agent/`（以及模块特定的 `*/doc/` 文件夹）用于面向 AI 的文档，`doc_human/` 用于面向人类的指南或设计文档。人类文档可能更冗长，不适合 AI 解析，因此我们相应地标记它们并将它们排除在 AI 的路由索引之外。相反，AI 可能需要的任何关键项目知识（即使是高级需求或设计决策）必须以 AI 可读的形式表示并集成到路由系统中。例如，如果有项目特定的需求文档或背景信息，我们将其作为路由中的叶子附加（具有适当的 `doc_kind`），以便 AI 不会忽略它。此规则确保没有重要上下文停留在 AI 不可见的孤岛中。人类文档仍然可以为开发者存在，但 AI 的世界观保持全面且索引良好。所有 AI 文档都保持轻量级和面向行动，而人类文档可以承担更多叙述性。通过将它们分离，我们防止 AI 意外地遍历冗长的面向人类的文本，或被不适用于它的内容所混淆。

### 面向 AI 的命名和结构

整个仓库被组织为可预测的 AI 导航。除了已经讨论的核心文件外，目录命名约定（全部小写，文件使用 kebab-case）和结构化子文件夹（例如，每个模块具有 `frontend/`、`backend/`、`tests/` 等）有助于 AI 推断在哪里找到内容。每次脚手架创建新模块时，它都会生成相同的基线布局（文档、配置、代码文件夹），因此 AI 不会面临非结构化或临时布局。我们还避免过时或不明确的术语。例如，初始化模块的"八个文档"的旧概念被移除，转而明确列出脚手架应创建的必需文件（manifest、routing、agents、ability 等）。这消除了需要存在什么内容的歧义。总的来说，AI 友好性原则是关于使仓库的知识明确、标准化且易于遍历，以便 AI 可以充当有效的开发助手，而不会因格式不一致或缺失上下文而绊倒。

## 模块化开发

模块化开发是一个原则，确保仓库被结构化为定义良好、松散耦合的模块，使人类开发者和 AI 代理都能在清晰的边界内工作。每个模块封装一组相关功能（例如功能或服务区域）及其自己的文档、配置和代码。这不仅反映了良好的软件工程实践，还通过限制任何单个操作的范围来帮助 AI 管理上下文。

### 模块结构和脚手架

仓库在 `modules/` 目录下组织，包含每个模块实例的子文件夹。我们采用模块命名方案，如 `mod_<domain>_<name>` 以确保清晰性和一致性（例如，`mod_order_core` 用于核心订单管理模块）。在启动新模块时，开发者（或通过自动化脚本的 AI）使用脚手架工具生成模块的骨架。此脚手架创建：

- 具有标准子结构的模块目录（根据需要为代码提供 `frontend/`、`backend/`、`core/`，以及 `tests/` 等）。
- 关键文档文件：一个 `AGENTS.md`（模块本地策略）、一个 `ABILITY.md`（模块的能力索引），以及如果模块有子部分或多个功能，则可选地有一个 `ROUTING.md`。它还创建一个 `MANIFEST.yaml`，记录模块的元数据（如其类型和任何依赖项）。
- 上下文和配置的占位符：例如，模块的空 `workdocs/` 目录（用于该模块特定的 AI 工作日志）、一个 `doc/` 文件夹用于任何额外的知识文档，以及一个 `config/` 文件夹用于模块特定的配置。
- 可选地，一个 `init/` 子文件夹，在模块设置期间使用（带有问卷或生成的临时文件）；在初始化完成后将其删除以避免混乱。

脚手架自动在全局索引中注册新模块。例如，它将向中央 `instance_registry.yaml` 添加一个条目，列出所有模块实例，并更新模块关系图（下面更多内容）。通过强制模块创建仅通过此脚手架进行（绝不手动），我们确保每个模块都以 AI 编排所需的文档和元数据开始，不会遗漏任何内容。脚手架还运行验证（lint 检查）以确认新模块的路由和命名正确设置，并且虚拟测试通过，然后才认为模块就绪。重要的是，模块初始化提供一个完全连接但为空的模块——所有钩子、文档和配置都已就位，但它不会强制提前编写任何业务逻辑。这允许开发（由人类或 AI）在该模块中继续进行，已经存在坚实的模板和护栏。

### 封装和边界

每个模块作为开发的自主上下文。AI（和开发者）应该尽可能将模块视为有界单元。为了加强这一点：

- **能力所有权**：系统中的每个高层能力都由单个模块拥有（通过注册表中的 `owner_module` 或 `owner_id` 记录）。这意味着，例如，能力 `able.payment.process_invoice` 将属于支付模块，编排器会将其视为该模块域的一部分。即使它在内部调用其他模块的能力，从外部看，它是由支付拥有的一个功能单元。这避免了 AI 试图以不受控制的方式跨多个模块编排一个任务的情况。

- **跨模块依赖**：跨模块调用通过显式依赖处理。模块的清单可以声明它需要另一个模块（意味着它依赖于其某些功能）。在能力注册表中，我们标记用于被其他模块重用的能力与那些顶级业务入口点。例如，如果能力是供其他模块工作流调用的"实用程序"，则能力可能具有 `exposure: internal`，而 `exposure: public` 表示该模块的业务级入口能力。编排器的规划逻辑将倾向于使用单个模块的公共能力来完成任务，而不是将来自多个模块的内部能力串在一起。任何跨模块使用都作为依赖调用在幕后发生（"轮子重用"概念），并且不违反每个任务一个模块的指导原则。

- **模块层次结构和类型**：模块层次结构和类型被记录但保持在运行时逻辑之外。我们定义模块级别（分层包含）和模块类型（分类）的概念，主要用于设计和文档目的。例如，"前端"类型模块与"后端"类型，或更高级的分组模块。YAML 文件（类型图）作为模块类型如何关联的单一事实来源（例如，哪些类型可以调用哪些其他类型）。每个实例在其清单中声明它是什么类型以及它是否有父模块（在层次结构的情况下）。这些关系帮助 AI 和人类理解系统的结构（"该模块属于系统的哪一部分？"），并可用于验证声明的依赖是否有意义（CI 可以检查如果模块 A 调用模块 B，它是否被类型图允许）。但是，此类型/级别信息不直接用于能力的编排——它更多地用于指导设计和审查。我们避免将运行时编排与严格的层次结构规则纠缠在一起，除了能力所有权和暴露已经强制执行的内容之外。这样，如果暴露了，AI 可以灵活地使用来自另一个模块的实用程序，但它总是通过调用模块的包含高级能力来启动它（对外部保持单模块操作的外观）。

### 开发工作流和隔离

我们施加一些工作流规则以保持模块隔离：

- **每个 PR 一个模块**：代码更改通常一次限制在一个模块内。拉取请求不应包含跨多个模块的随机更改。如果功能真正跨越模块，应该通过父跟踪问题和每个模块的单独 PR 来管理，而不是一个大 PR。这种做法由团队约定和 AI 护栏强制执行，确保更改保持本地化且更易于分析。我们的 CI 可以将触及太多模块的 PR 标记为可能违反此规则。

- **安全模块删除**：删除模块是一个复杂的操作，我们谨慎地保护它。在 AI（或开发者）删除模块的代码之前，它必须清理或重新分配模块的任何能力和文档。注册表或其他模块中对它的所有引用必须得到解决。我们添加护栏策略，如果这些条件未满足，则阻止删除。AI 被引导一次处理一个模块或功能——即使是大型重构也被限制为在一次操作中专注于单个模块，减少进行广泛、不可审查更改的机会。

- **模块代理**：在 AI 方面，每个模块可以被认为具有自己的"模块代理"角色，由模块的 `AGENTS.md` 封装。该文件是该模块在文档路由中的叶子策略节点——意味着它是 AI 找到最终、模块特定指令或约束的地方。对于简单模块，这可能只是列举模块的目的、任何已知的风险因素和允许的工具。对于具有多个场景的复杂模块，模块的 `ROUTING.md` 可以进一步分解为子策略文档，但最终 AI 会将模块的 `AGENTS.md`（以及它链接的任何内容）视为该模块策略链的末端。这使策略保持去中心化：全局策略位于根 `AGENTS.md` 中，特定领域的策略位于 `doc_agent/AGENTS.md` 中（作为策略索引），模块特定的策略位于每个模块的文件夹中。AI 根据需要根据范围读取它们，这意味着它始终使用正确的本地指导原则进行操作。

总之，模块化开发原则建立了一个脚手架，AI 和人类可以一次处理系统的一个部分，副作用最小。它提供了代码和能力所有权的清晰性，并使用自动化（脚手架、注册表）来维护一致的模块生态系统。这不仅有助于并行开发，还意味着 AI 不会意外地纠缠上下文——它知道哪些文档和能力属于哪个模块，并尊重这些边界。

## 自动化维护

自动化维护包括保持仓库健康和安全演进的工具、检查和流程，手动开销最小。此原则利用 CI/CD 管道、自动化测试和自我调节机制（通常由 AI 驱动），以便持续开发不会降低项目质量。本质上，仓库模板包括内置的"看护者"功能，处理日常维护任务并强制执行标准。

### 持续集成检查

模板提供了一套全面的 CI 检查，在每次提交/PR 和按计划运行时执行。这些包括：

- **文档和路由一致性**：工具定期扫描所有 `ROUTING.md`、`AGENTS.md` 和 `ABILITY.md` 文件，以验证它们符合模式并且所有交叉引用都有效（无断开的链接、缺失的文档或不同步的条目）。检查前置元数据的必需字段，如果任何路由条目指向不存在的文档或列出的能力未注册，CI 将标记它。这确保随着项目增长，AI 的"地图"（路由和能力索引）保持准确。

- **能力契约测试**：对于每个注册的高层能力（特别是标记为稳定的能力），我们至少包含几个测试用例（可以是单元测试或集成试运行），以验证能力按文档所述行为。CI 运行这些测试以捕获代码和文档之间的任何分歧。例如，如果 `able.repo.backup_project` 应该调用某些步骤并产生输出，测试将模拟该调用并验证结果，确保 AI 可以信任能力定义。低层方法（脚本）也可以有测试，但重点是高级能力的契约，因为这些驱动编排。

- **触发器/护栏模拟**：我们定期运行自动化管道本身的"试运行"——模拟最近更改上的触发器，以确保我们的触发器/护栏配置按预期工作。这可能涉及创建一个虚假场景的脚本（例如，假装提出了危险操作），以查看正确的触发器是否会触发以及正确的护栏是否响应。通过在安全上下文中执行自动化，我们确信它将在实际使用中正确行为。我们还保留触发器的指标：每个触发器触发的频率、护栏阻止操作的平均时间等，以持续完善规则（这更多是监控方面，可能作为单独的报告实现）。

此外，CI 包括常规检查，如代码风格检查、运行软件本身的单元测试等，但这些通过工具按常规配置。我们确保这些检查专注于我们文档定义的重要方面，以避免不必要的复杂性。例如，我们可能强制执行没有 PR 引入大量代码重新格式化（样式更改是隔离的），如文档中注明的样式指南。

### 触发器和护栏治理

作为维护的一部分，触发器和护栏被视为一等配置。它们在 YAML 文件中定义（例如 `doc_agent/triggers/agent-triggers.yaml` 和类似的护栏文件），并像代码一样进行版本控制。这意味着对安全规则的任何更改都经过代码审查。我们提供工具来管理这些规则：

- 一个生成器工具，用于创建具有适当字段的新触发器/护栏条目，以便添加新规则（如对某个文件模式的检查）得到指导且不易出错。
- 一个触发器/护栏的 linter，检查冲突（例如，两个具有相同优先级和重叠模式的触发器）或不可达状态、相互排斥等。
- 为这些配置维护文档，描述命名约定（每个触发器都有一个命名空间，如 `domain.scope.action`）、优先级级别，以及如果规则冲突该怎么办。这确保了自动化安全措施如何工作的透明度。通过系统化策略更改，我们防止 AI 可能不知道的"隐蔽"更改。AI 读取 `AGENTS.md` 必读列表，其中包括触发器/护栏原则和优先级的概述，因此它理解治理模型。

### 自动化上下文管理

随着时间的推移，AI 将在 `workdocs/active/` 日志中积累大量上下文。为了防止这些无限增长或污染新会话，我们实现了一个自动化上下文清理机制。使用滑动窗口 + 摘要方法，计划任务定期修剪 workdocs：

- 如果 workdoc 变得太大（例如，超过一定数量的行或条目）或太旧（N 天没有最近更新），维护脚本将汇总较旧的内容并将摘要移动到存档（例如 `workdocs/archive/summary/`）。
- 然后活动 workdoc 被修剪为仅最近、相关的内容。这使活动上下文文件保持精简，因此如果 AI 重新加载它们，它不会摄入不相关的历史记录。
- 我们将时间戳和更新计数器附加到 workdoc 条目，以便工具可以决定何时触发清理。值得注意的是，此清理由 CI 或 cron 作业完成，而不是由 AI 代理本身实时完成。这是一个有意识的决定，以保持其可预测性并防止 AI 意外删除它仍然需要的上下文。AI 只是写入 workdocs；维护任务按计划处理清理，例如每晚或每周。

此外，我们要求 AI 在工作时在 workdocs 中标记任务状态（`pending`/`in_progress`/`completed`）。这种状态跟踪（AI 实时更新）为 AI 和人类提供了快速查看哪些任务是开放的或已完成的视图，并可以用于决定可以汇总哪些旧上下文。它提高了 AI 进度的透明度。

### 项目初始化自动化

另一个维护方面是我们如何处理将此模板用于新项目。我们包括一个项目初始化脚本（在模板的 `/init/` 目录中），它自动化将模板转换为特定项目的定制仓库的过程。在启动新项目时，用户（可能由 AI 指导）将运行此初始化器，它：

- 交互式地询问项目特定的详细信息，甚至接受初始需求文档作为输入。
- 在整个模板中填写配置文件、项目名称和其他占位符。
- 删除仅模板需要但实际项目不需要的示例内容，包括完成后 `init/` 目录本身。
- 确保初始化后，所有文档和路由都是一致的（可能运行 CI 检查的子集），以便新项目仓库处于"就绪"状态。目标是生成的项目需要最少的手动调整；它应该具有所有核心文档并通过基线测试（仅使用占位符逻辑）。

此机制是关于自动化模板在转换为真实项目时的维护——本质上是从第一天开始使用相同原则引导项目。它防止初始设置中的人为错误，并保证即使是新仓库的第一次提交也遵循 AI 集成的结构。

### 持续改进循环

最后，模板渴望从经验中学习。我们引入了自动化课程集成的想法：系统可以分析 workdocs 中的常见错误或重复更正，并将改进反馈到知识库中。例如，如果 AI 在执行某个任务时反复遇到错误，人类提供了修复，工具可以检测此模式并更新指南或在故障排除文档中添加新的问答。这仍然是一个实验性概念，但愿景是仓库可以半自主地随着时间的推移改进其文档和规则。我们计划将其实现为后台进程，扫描存档的 workdocs 以查找值得注意的"经验教训"，并建议更新相关策略文档或快速入门，需要审查。通过这样做，文档和策略的维护变得主动：AI 自己的经验有助于完善它将来将遵循的指导，创建一个良性改进循环。

### 人类监督和范围外保障

即使有大量 AI 自动化，人类开发者仍然控制仓库。所有 AI 操作（代码更改、文档更新）都通过正常的 git 过程（PR、代码审查）进行，除非明确批准为自主模式。护栏系统确保任何潜在的风险更改（如更改 API 合同或在生产环境中执行模式迁移）要么涉及人类确认，要么至少通知人类。此外，某些功能被有意保持在基础模板的范围之外，以避免过度复杂化——例如，多语言支持、AI 使用成本监控或用户反馈循环被承认是可能的未来增强，但默认情况下不包括。这使维护重点保持在核心开发过程上。模板确实为这些关注点提供了扩展点（例如，可以集成成本护栏的占位符），但它们最初被禁用或留作存根。这种受控范围本身就是一个维护决策：它防止 AI 被当前项目实现域之外的关注点分散注意力，除非这些功能被故意打开。

通过尽可能自动化"繁忙工作"——从强制执行编码标准和文档一致性到清理上下文和纳入新经验——仓库模板确保 AI 和人类贡献者都可以专注于创造性开发而不是繁琐的维护。结果是一个持续自我审计、自我改进的系统，AI 可以被赋予更多自主权，而不会牺牲可靠性或可追溯性。

## 结论

通过智能编排，AI 被引导以受控、上下文感知的方式做出决策和执行任务。通过文档和项目设置中的 AI 友好性，AI 可以像人类开发者一样（甚至更好）理解和导航仓库。模块化开发提供了清晰的边界和可扩展的结构，实现了并行开发和可管理的复杂性。自动化维护通过确保系统自我调节并随着时间的推移保持最新、安全和高效来闭合循环。

本蓝图作为 AI 集成仓库模板的基础设计。它不仅仅列出了一组文件或目录，而是 AI 代理和人类在软件项目中协作的连贯方法论。通过遵循这些原则和机制，团队可以实现高度自动化和 AI 增强的开发过程，同时保持可控、透明并与人类意图一致。仓库模板不仅仅是一个代码骨架——它是一个编排和知识框架，在维护结构和质量的同时，赋予开发中深度 AI 参与的能力。所有这些措施旨在取得平衡：利用 AI 的速度和能力，由强大的规则和上下文框架指导，以实现更快、更安全的持续软件交付。

