
# 模块化开发

我们认为，通过限制任何单个操作的范围可以提高AI上下文管理效率。为使人类开发者和AI代理都能在清晰的边界内工作，我们将模块化开发作为基础原则，鼓励将仓库被结构化为定义良好、松散耦合的模块。

我们围绕模块化开发设计了整套的相关规范，用来以模块为单位管理基础设施（如知识/功能路由等）。也就是说，模块是构成项目的基础单元，同时也是其他主要基础体系的唯一载体，需要自行维护独立的配置、策略、工作记录、和代码实现。并维护自身允许使用的功能路由和知识路由。

和模块相关的概念主要有三个： module_level（层级）、module_type（类型）、module_entity（实例）
-  **模块实例**是面向业务的，是实际开发的唯一载体，前端/后端/逻辑的实现都需要对应到模块实例。
-  **模块类型**是用来描述业务流和数据流，类型间的调用/依赖关系，组成图结构
-  **模块层级**和类型是解耦的，层级描述实例的组成/包含关系，构成关系树


## 信息维护（info maintain）

SSOT

- 新模块注册
- 新类型注册

- 内容修改
- 层级维护

## 典型架构（structure）

- YAML 清单文件（例如 modules/<mod_id>/MANIFEST.yaml），捕获模块的关键元数据（其 module_type、对其他模块的任何依赖、作者等）。
  - 模块根目录中的核心 AI 文档文件：
    - `AGENTS.md`：模块的本地策略（如果模块有任何执行或特殊规则；参见 Phase 4）。
    - `ABILITY.md`：模块的本地能力索引，列出在该模块内定义的任何能力（这通过限定到模块的能力范围来补充全局能力索引）。
    - `ROUTING.md`：如果模块包含多个文档主题或子指南，则为模块的文档路由器。对于简单模块，这可能不需要（模块可以作为全局路由中的叶节点处理）。

  - 模块内容的标准子目录，例如：
    - `doc/`：用于额外的模块特定文档（指南、合同、与此模块相关的规范）。
    - `workdocs/`：用于模块特定的进行中笔记（尽管主要 workdocs 通常在仓库级别，模块特定任务可以在此处跟踪（如果需要））。
    - `config/`：用于模块配置文件。
    - 代码目录，可能包括 `backend/`、`frontend/`、`core/` 等，具体取决于技术（确切结构将遵循约定，例如，Web 模块可能有 api/ 或 service/ 目录）。

## 工作记录（AI workdocs）

每个模块实例都需要维护工作记录，骨架结构形如
```
workdocs/
├── AGENTS.md              # This file
├── active/                # Current work
│   ├── task-1/
│   │   ├── task-1-plan.md
│   │   ├── task-1-context.md
│   │   ├── task-1-errors.md
│   │   └── task-1-tasks.md
│   │   └── task-1-details.md
│   └── task-2/
│       └── ...
└── archive/               # Completed work (optional)
    ├── summary/
    ├── old_tasks/
        └── ...
```


workdocs/active/




## 初始化


模板将实现一个模块初始化的脚本，通过脚手架和注册表来维护模块生态系统的一致性。

生成过程中会在临时文件目录下完成

主要流程如下：
  1. 创建目录：创建`modules/<mod_id>/init/`，用于存放过程文档（如需求文档、必要信息记录、特殊要求等）以及充当创建期间的暂存区。该目录为临时目录，将在初始化流程结束后删除；
  1. 交互式信息收集：AI（或开发人员）将提供或被要求提供必要的详细信息，如模块领域、名称、类型和任何初始配置（如是否连接到数据库等）。
  2. 生成模块骨架：创建目录 modules/<mod_id>/，使用上面列出的文件填充它（使用提供的信息填充 YAML 前置元数据或清单中的占位符，例如，模块名称、类型、日期、所有者）。

  3. 注册模块实例：向模块注册表添加一个条目，结合前序步骤收集的信息和格式规范填写内容。
  4. 类型关系维护：如果模块对应的类型为新类型，则需要在
  
  5. 如果模块预期具有公共能力，脚手架可能还会在全局能力注册表中插入一个骨架条目（初始成熟度为 candidate，稍后由开发人员/AI 完善）。
  6. 生成后，脚手架可以运行快速一致性检查：例如，以验证新模块的文档已链接（新模块的 ROUTING 包含在父路由中等）、命名正确，甚至可以执行占位符测试（如空测试通过）的模式运行 make dev_check。只有当这些都通过时，模块脚手架才被视为完成。
  7. 确认后，脚手架可以提示删除 init/ 文件夹并将模块标记为就绪。


初始化过程提供的是一个完全链接但内容为空的模块，保证模块实例可以嵌入其他主要的体系，但不会提前编写任何业务逻辑。



它提供了代码和能力所有权的清晰性，并使用自动化（脚手架、注册表）来维护一致的模块生态系统。这不仅有助于并行开发，还意味着 AI 不会意外地纠缠上下文——它知道哪些文档和能力属于哪个模块，并尊重这些边界。


**开发模块脚手架过程**：我们将实现一个脚本（例如，在 scripts/scaffold-module/ 下）以自动化模块创建

  1. 交互式信息收集：AI（或开发人员）将提供或被要求提供必要的详细信息，如模块领域、名称、类型和任何初始配置（如是否连接到数据库等）。
  2. 脚手架脚本然后生成模块骨架：创建目录 modules/<mod_id>/，使用上面列出的文件填充它（使用提供的信息填充 YAML 前置元数据或清单中的占位符，例如，模块名称、类型、日期、所有者）。
  3. 它创建一个 modules/<mod_id>/init/ 文件夹，其中包含设置的任何临时资源——例如，脚手架用于生成模块的快速入门指南或问卷，或一些生成的示例/测试。此 init/ 文件夹在创建期间充当暂存区（例如，可能存储中间答案或模块的初始待办事项列表）。模块完全初始化和验证后，将删除此文件夹（想法是所有需要的内容要么在清单中，要么在文档中，任何临时说明不会混乱最终仓库）。
  4. 脚手架还将更新中央索引：它将向模块注册表 YAML（我们计划 doc_agent/modules/instance_registry.yaml）添加一个条目，列出新模块、其类型和关系。如果需要，它将更新根 README 或路由中的任何全局列表（例如，将模块添加到根文档中的模块目录表）。
  5. 如果模块预期具有公共能力，脚手架可能还会在全局能力注册表中插入一个骨架条目（初始成熟度为 candidate，稍后由开发人员/AI 完善）。
  6. 生成后，脚手架可以运行快速一致性检查：例如，以验证新模块的文档已链接（新模块的 ROUTING 包含在父路由中等）、命名正确，甚至可以执行占位符测试（如空测试通过）的模式运行 make dev_check。只有当这些都通过时，模块脚手架才被视为完成。
  7. 确认后，脚手架可以提示删除 init/ 文件夹并将模块标记为就绪。
- **定义模块初始化完成标准**：我们明确说明，当模块具有所有结构和文档元素（在索引中注册、路由可达、策略到位、任何能力或代码的占位符（如需要））时，模块被视为已初始化，但它不需要提供实际的业务功能。换句话说，脚手架后，模块将是空的真实逻辑（除了可能的一些模板代码或示例测试），这是可以接受的。目标是确保骨架通过所有检查并准备好填充。不完整的存根不应破坏 CI。这种方法鼓励小的初始 PR，仅添加结构，然后后续开发添加真实功能。



- **澄清路由的注册范围**：我们确认只有路由文件本身及其直接叶节点在 context_routes 索引中明确列出。我们不会尝试注册每个子节或示例文件——叶文档内的子节应由 AI 根据需要逐步发现，而不是在路由中枚举（以避免索引过载）。面向人类的文档完全保留在路由索引之外。这种方法使路由表保持专注和可维护。
- **实现路由前置元数据和元数据**：每个 ROUTING.md 将包含一个前置元数据（带有 doc_kind: router、audience 等）和标准化结构。内容可能是将 scope/topic/when 映射到 target_docs 的表格或列表。我们还将维护一个中央 YAML 文件（例如 doc_agent/orchestration/doc-node-map.yaml），作为所有文档节点及其角色的权威注册表。此映射将帮助自动化工具验证路由文件和实际文档之间的一致性。
- **遵守分层路由责任**：顶级 ROUTING.md 专注于广泛的"读什么/去哪里"方向，而较低级别的可能包含更多特定上下文的说明或链接到快速入门和指南。我们避免在多个级别重复内容；每个 ROUTING.md 仅指向下一级别或最终文档，而不是重复这些文档的细节。这使每个路由文件保持简洁，整体导航清晰。
- **为核心主题创建初始路由条目**：例如，根 ROUTING.md 可能有一个条目，如 Scope: "文档与标准" – Topic: "仓库约定" – When: "设置或更新文档"，指向文档指南或标准（可能在 doc_agent/guide/ 目录中）。另一个例子：Scope: "执行 – 数据库" – Topic: "模式更改" – When: "修改数据库模式或迁移"指向 DB 子系统的文档（如 DB 规范或迁移指南）。同样，执行 – API 条目将路由到 API 网关和合同文档。我们将根据后续阶段开发的内容填充这些路由（Phase 6 用于 DB，Phase 7 用于 API 等），但占位符和结构将在现在建立。
- **设置管理路由的工具**：我们计划实现或配置脚本来验证和刷新路由索引。例如，doc_node_map_sync 脚本可以解析所有 ROUTING.md 文件以构建 doc-node-map.yaml，反之亦然，确保没有死链接或孤立文档。将引入 make route_lint 命令来捕获错误，如缺失的路由目标或引用文档中不一致的前置元数据。


**原理**：模块化架构为模板提供了可扩展性和可维护性。它允许不同的团队或 AI 代理在项目的不同部分工作而不会相互干扰，并帮助编排器通过分段任务来管理上下文。通过使用所有必要的文档和配置搭建模块，我们确保每个模块从一开始就是 AI 就绪的。讨论强调了消除"八个文档"的过时概念来生成，而是明确列出为模块需要创建的内容——我们的脚手架方法通过生成恰好需要的文件来解决这个问题，避免混淆。模块类型系统鼓励相似性质的模块之间的一致性，并帮助 AI 理解项目结构（"这些模块遵循模式，以定义的方式连接"），这可以改善其规划（例如，知道所有"controller"类型的模块应该调用"service"类型的模块）。类型图作为单一事实来源（SSOT）确保我们有一个维护的模块关系模型，我们可以使用它来验证清单声明，甚至可以根据需要自动生成系统架构图。通过不维护单独的手动图表给人类（可能会不同步），我们减少了文档漂移。围绕模块更改的防护栏解决了一个关键风险：AI 过于广泛的重构可能导致混乱；实施一次一个模块的规则可以缓解这种情况。所有这些措施旨在保持系统模块化、可理解并在演进过程中受控。

**预期成果**：到 Phase 5 结束时：

- 仓库将包括至少一个示例模块（可能是"base"或模板模块）完全搭建，展示结构，MANIFEST.yaml、AGENTS.md、ABILITY.md 等已就位。其他中心模块（如用于 API 的 api_gateway 模块，或如果以这种方式构建的 db 模块）也将在现在或它们各自的阶段搭建。
- 模块脚手架脚本将通过创建虚拟模块来实现和测试。它应该生成一个模块，其中在创建后立即运行 make dev_check 通过（意味着文档已链接，任何占位符测试通过等）。
- 实例注册表（instance_registry.yaml）将包含模块的条目（包含类型等），并且将创建类型图（type_graph.yaml）来描述允许的模块类型关系。CI 应包括检查，确保每个模块实例的 module_type 在类型图中定义，并且其声明的 requires_modules（依赖项）在该图中是允许的边。
- 文档：doc_agent/guide/module.md（面向 AI）将以约 100 行或更少的篇幅概述模块级别、类型、实例定义。相应的 doc_human/guide/module.md 将为开发人员提供更详细的说明，可能包括模块交互的示例或场景。
- 我们将更新全局 ROUTING.md 以包括一个枚举可用模块的部分（至少将它们作为导航的一部分列出）。例如，根 README/ROUTING 可以有一个模块摘要表和指向它们的快速入门或主文档的链接，以帮助 AI 轻松找到模块入口点。
- 防护栏/触发器配置（尽管在 Phase 8 中完全处理）将有占位符或初始规则，以确保模块添加运行所需的同步脚本（用于更新图和注册表），并且删除或多模块更改会被标记。我们将验证尝试在不遵循程序的情况下删除模块会触发警报。
- 有了模块化基础，我们可以继续在后续阶段进行领域特定的集成（DB、API），确信它们将正确插入此模块系统（例如，api_gateway 是特定类型的模块，DB 迁移可能属于 db 模块或类似）。基本上，到此阶段，将仓库扩展到多个模块的基础设施已就绪，并且初始模块已就位，以满足下一个功能的需要。



## 体系协同（collaboration）
所有的功能/知识/触发器，都需要挂在到具体的模块实例下
- 知识路由体系

- 能力路由体系

- 运行策略
- 触发器体系




有了上述结构，AI 编排周期的工作方式如下：AI 获取任务，查阅顶级 `ROUTING.md` 以定位相关上下文（并读取 `AGENTS.md` 中的任何必需策略），从能力注册表中识别合适的高层能力，然后执行它。编排器使用一个将上下文 → 策略 → 能力映射的决策流程：

- **上下文查找**：通过路由文件中的 context_routes（范围/主题/时机）找到正确的文档。
- **策略检查**：在继续之前，为该上下文加载任何必需的护栏或策略（来自 `AGENTS.md`）。
- **选择能力**：选择与任务意图匹配的高层能力（工作流/代理）（能力注册表按域和意图组织），并检查是否允许（只有稳定的能力对编排器可用——参见维护部分）。
- **执行计划**：运行高层能力，它按照其步骤中定义的方式编排低层方法调用（脚本、API 调用）。编排器不会微观管理低层调用；它委托给工作流/代理定义，这确保了多个步骤的一致执行。
- **迭代或移交**：如果任务需要多个步骤或子任务，编排器可能会循环返回以获取更多上下文或能力用于下一步（始终遵循路由和策略指导）。在某些情况下，它可能会移交给专门的子代理（例如，用于一系列数据库操作的"DatabaseOps"代理），如能力图中定义的那样。
