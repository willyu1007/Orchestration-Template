
标准化文档格式、命名约定、目录结构，并确保文档针对 AI 消费进行了优化

- **定义文档角色和受众**：所有文档必须清楚地标明是面向 AI 还是面向人类读者（在前置元数据中），并遵守特定角色的指导原则。面向 AI 的文档（如路由指南、代理策略、能力索引等）应保持简洁（通常 <150 行）且高度结构化，而面向人类的文档（例如 README）没有严格的长度限制，但应标明 AI 可以忽略它们。

- **执行格式和样式规则**：所有文档使用 UTF-8 编码和 Markdown 格式。所有内容生成和编辑（除非用户特别要求）应为英文。避免非结构化散文或过度使用表情符号/符号（简单的状态图标除外）。
  
- **建立文件、目录和代码的命名约定**：例如，文档文件使用 kebab-case（例如 data-spec.md），环境常量使用 UPPER_SNAKE_CASE，Python 变量/函数使用 camelCase，类使用 PascalCase，数据库实体使用 snake_case。标准命名模式可防止混淆和冲突（例如，使用 <topic>-<type> 或 <topic>.<type> 后缀以提高清晰度）。
  
- **组织文档目录**：所有面向 AI 的文档将位于专用路径下，如 doc_agent/（用于 AI 特定知识）或模块特定的 doc/ 子文件夹中，而面向人类的文档（除高级 README 外）将位于 doc_human/ 下或明确分离，以避免混合上下文。进行中的上下文笔记将位于 ai/workdocs/（包含 active 和 archive 子文件夹）中，内部报告位于 ai/reports/，确保 AI 不会意外加载无关的人类导向或归档内容。
  
- **为所有 AI 可读文档准备前置元数据模式**：每个此类文件必须以标准化的 YAML 前置元数据开头，声明字段如 audience（必须是 "ai" 或 "human"，不能两者兼有）、purpose、doc_role（例如 quickstart、guide、spec、contract 等）、doc_kind（例如 router、agent_policy、capability_index 等），以及元数据如 updated_at 和所有权标签。叶节点文档（路由指向的最终内容文档）应在前置元数据中包含 route_role: leaf，以标记它们为文档路由树中的端点。我们还将引入模式文件（例如 spec/front-matter.schema.yaml 等）来定义这些前置元数据结构，并启用文档格式验证。
  
- **在文档设计中实现"渐进式披露"原则**：顶级 AI 入口文档（如 ROUTING.md）将保持极其轻量——仅列出基本角色、导航链接或常用命令，没有冗长的背景文本。更深入的详细信息被推迟到较低级别的指南或规范中，通过链接引用，因此 AI 只读取当前任务所需的内容。高级文档回答"做什么，在哪里找到它"；中级文档作为特定任务的手册或策略；低级文档提供完整的技术细节或示例。这种结构帮助 AI 最初加载最少的内容，然后根据需要逐步获取更详细的文档（避免令牌溢出）。我们将把这种渐进式加载方法编入文档编写的最佳实践（例如，在文档中添加关于下一步应阅读哪个文档或部分以获得更深入信息的注释）。
  
- **确定要在仓库根目录和模块中存在的核心文档文件**：按照约定，每个作为导航中心的目录将包含一个 ROUTING.md（用于导航），如果该目录包含 AI 可执行组件，则可能包含一个 ABILITY.md（原名 CAPABILITIES.md，用于能力索引）和一个 AGENTS.md（用于本地代理策略）。但是，根据修订后的共识，仓库的根目录将保存主要的 AGENTS.md，作为整个项目的单一全局策略和防护栏入口（整合全局规则）。模块目录如果有自己的执行逻辑，可以有自己的 AGENTS.md，但要求在每个子目录中都有所有三个文件的要求已放宽，以减少冗余。如果目录纯粹用于文档或不托管活动代理，它可以省略本地 AGENTS.md 或 ABILITY.md，更高级别的路由将简单地链接到该模块中的相关文档。



> 该步骤的主要目标为建立健全的大模型文档操作规范 ，包括格式要求、路径规范、关联操作、特殊定义说明等。
> 重点说明：repo的核心要素是AI友好，所以文档要优先保证

文档路由体系由各级 `ROUTING.md` 构成，负责告诉智能体去哪一层、哪个目录能找到主题相近的资料；真正承载内容的文档是路由的叶子节点。与此同时，`AGENTS.md`（doc_kind: agent_policy）专门向代码大模型说明本目录的安全边界、职责，以及如何与路由/编排体系配合；`CAPABILITIES.md`（doc_kind: capability_index）则列出该目录暴露给编排系统的能力节点、脚本入口或工具封装，便于能力检索。智能体到达叶子文档后，需要对照 front matter（如 `audience`、`purpose`、`doc_role`、`doc_kind` 等）确认自己加载的是正确目标，再继续阅读。  
渐进式原则则解决"怎么读"：抵达正确的位置后，只取当前任务需要的小文档或段落，避免一次性加载整套长文档，并在工作文档中记录已读信息以便后续恢复。

- 基本格式：
  - 需要支持UTF-8编码
  - 生成和修改文档必须使用英文（用户要求除外）
  - 除信号语义外（如✅， ❌， ⚠️，和系统风格的状态指示外），不允许使用颜文字，明确使用范围颜文字的使用情形和范围。

- 阅读对象要明确区分：文档要分为给人读的和给AI使用的。给AI使用的文档会形成文档路由体系（详见下一章节），所以需要区分文档角色和明确文档职责范围。
  - 给人阅读的文档：没有字数限制。需要在文档顶部以统一的格式明任务编排/智能体编排系统不用阅读。
  - 给AI阅读的文档：要保持轻量化（行数 < 150），使用结构化的语言风格，要注意遵循内容渐进式的原则（详见下文）。
  - 文档需要在顶部明确阅读对象（AI / human， 不允许both），职责范围，purpose，以及 `doc_kind`（router / agent_policy / capability_index / guide / spec / quickstart / workdoc 等）。
  - 面向AI的文档应保持轻量化，路由语义准确，内容分节清晰。路由说明详见第二章；`agent_policy` 文档须保持 ≤200 行，突出可/不可执行操作与 handoff 规则；`capability_index` 文档需在 250 行内描述能力拓扑、触发条件与入口。
  - 文档角色（面向AI的）：Router（即 ROUTING.md）、Agent Policy（AGENTS.md）、Capability Index（CAPABILITIES.md）、Guide、Specs、quickstart、规范、合约/契约、规程、脚本说明、Changelog 等。可以根据整体情况补充角色并在 `doc_agent/orchestration/doc-node-map.yaml` 中登记其与能力标签的映射。
  - 文档职责（面向AI的）：以Agent Docs为例，职责可以参考下述信息："ORCHESTRATOR: maintains routing, scope, and priority rules; MODULE AGENTS: enforce local guardrails and context for module tasks. SERVICE AGENTS: provide domain-specific protocols for schema or database work"。和文档角色一样，在阅读整体需求后，你需要自行完善。
  

- 渐进式原则：
	- 入口轻量：面向AI的主入口或具有路由功能的文档（如 `ROUTING.md`）只保留最小必需信息：角色、上下文路由、常用命令。不塞背景故事或长篇说明，避免一次加载过多token。
	- 逐层引用：把细节拆到下游文档，让上层通过路由/链接指向。当智能体有具体任务时，再加载对应的 quickstart、guide、spec 等文件。
	- 文档分层清晰：高层负责"做什么、去哪找"；中层提供操作手册；底层才给完整细节（流程、参数、示例）。结构越清楚，AI 越容易按需阅读。
	- 受众区分：AI 文档偏命令式、数据化；人类文档可以更长，但也尽量保持结构化。不要混杂在同一份文件中，以免上下文膨胀。
	- 保持入口精简：路由只指到下一层节点，不在同一文件重复列出全部内容；删繁就简的同时，用标题、表格、清单提升可搜索度。
	- 持续回收整理：更新流程或目录时同步调整路由，确认"重心文档"仍短小、可读。提醒通过工具定期检查。
	- 错误与经验记录独立化：遇到异常或经验总结，写入专门的 workdoc/ledger，而不是堆在入口文档里，保持基础文档不被杂讯拖长。

	- 写入规范
		- 路径要求：AI相关文档应该遵循路由规范，常见地址为doc_agent/下对应的类别，模块内部的 modules/<*name>/doc/等。面向人类的文档放在 doc_human/ 或其他有人工阅读需求的地方，除README.md外，要与AI文档分目录，避免混放。工作文档和临时上下文目录为ai/workdocs/(active/archive)。报告类文档放入 ai/reports(active/archive)。评估与基线类文档放到 ops/evals/中，并要避免误加载。
	- 报告类文档不要使用主观评估（如"预计效率提升xx%"等），要保持精简，描述事实、指标、后续计划，阐述重点，保持可读性。
	- 有较大变动时，在相关 CHANGELOG / workdoc 中记短摘要，方便溯源，并明确修改时间
	- 引入其他文件要使用相对路径
		- 入口文件分层维护：`ROUTING.md` 只写路由树与常用命令；`AGENTS.md` 只写策略、边界、工具使用守则；`CAPABILITIES.md` 只写能力列表、graph 节点、脚本/服务入口。若目录没有可执行智能体，可省略 `AGENTS.md` 与 `CAPABILITIES.md`；若仅提供策略或能力而无路由，则仍需在上层 `ROUTING.md` 中登记"只读策略/能力索引"路径。
	- 优先使用标题、表格、步骤列表等结构化数据；禁止大段散文
		- 文档正文使用Markdown(.md) ，必要时可附带 JSON/YAML 代码块，但主文件不要改用 HTML/Docx，搭配 YAML front matter（用于声明文档头信息）；配置与路由统一使用YAML，新增字段要遵循现有schema；提示词/模板可以选用Markdown（说明和示例）或YAML（结构化变量定义），但需要在规范中写明哪类文件用哪类后缀；如果专门定义JSON Schema或其他协议文件，在schemas/或对应目录，用.yaml或.json，并在 README / ROUTING.md / AGENTS.md / CAPABILITIES.md 中链接。不要混用富文本格式（word，HTML）或非结构化纯文本，保持UTF-8编码。
	- 文档顶部需要包含格式统一的 front matter， 如果文档内容发生变化，需要检查front matter是否也需要变更
	- 被路由指向的叶子文档必须在 front matter 中声明 `audience`、`purpose`、`doc_role`（例：quickstart/guide/spec/contract），并推荐增加 `route_role: leaf` 供自动校验；命名建议与角色一致（如 `quality-quickstart.md`、`db-spec.md`）；智能体读取时需比对这些字段确认目标正确


- 文档结构
文档必须按以下顺序组织：

1. **Front Matter**（前置元数据）
   ```yaml
   ---
   audience: ai | human | both
   language: en | zh | ...
   version: summary | reference | quickstart | template | ...
   purpose: <简短描述>
   ---
   ```

2. **标题** + 简短描述

3. **章节顺序**：从高级上下文到详细步骤

4. **清单/表格**：用于可操作的工作

5. **参考资料/链接**：放在文档末尾

   写作技巧
- 使用主动语态和精确的动词
- 用测量或命令替换轶事
- 链接到脚本/文档而不是重复说明
- **AI文档保持 ≤150 行**；人类文档可以更长但仍需聚焦

- Front Matter 字段说明

| 字段 | 可选值 | 说明 |
|------|--------|------|
| `audience` | `ai`, `human`, `both` | 目标受众 |
| `language` | `en`, `zh`, 等 | 文档语言（必须匹配 `config/language.yaml`） |
| `version` | `summary`, `reference`, `quickstart`, `template`, `playbook` | 文档版本类型 |
| `purpose` | 自由文本 | 文档目的简短描述 |

- 维护清单
创建或更新文档时检查：
- [ ] 头部存在且准确
- [ ] 语言匹配配置
- [ ] 内容仍然相关（删除已弃用部分）
- [ ] 链接的文件存在
- [ ] 护栏引用是最新的

- 文档类型与行数限制

| 文档类型 | 位置 | 行数限制 | 语言 |
|---------|------|---------|------|
| **AI Docs** | `doc_agent/`, `AGENTS.md`, quickstarts, specs | ≤150行 | 仅英文 |
| **Human Docs** | `doc_human/`, 模块模板, 项目报告 | 无严格限制 | 配置的语言 |
| **Dual Docs** | `README.md` 等 | 适中 | 配置的语言 |

---

- 命名规范

**参考文件**: `doc_agent/coding/AI_CODING_GUIDE.md`, `doc_human/guides/CONVENTIONS.md`

- 代码命名规范

- Python
- **类名**: `PascalCase`（例如：`UserService`, `DatabaseConnection`）
- **函数/方法名**: `snake_case`（例如：`get_user_by_id`, `validate_input`）
- **常量**: `UPPER_SNAKE_CASE`（例如：`MAX_RETRY_COUNT`, `DEFAULT_TIMEOUT`）
- **变量名**: `snake_case`（例如：`user_id`, `config_data`）
- **私有属性/方法**: 前缀单下划线 `_private_method`

- 文档文件
- **Markdown 文档**: `UPPER_SNAKE_CASE.md` 或 `kebab-case.md`
  - 示例：`DOC_WRITING_STANDARDS.md`, `module-init.md`
- **配置文件**: `lowercase.yaml` 或 `lowercase.json`
  - 示例：`defaults.yaml`, `schema.yaml`, `language.yaml`
- **模板文件**: `kebab-case.template` 或 `UPPER_SNAKE_CASE.md.template`
  - 示例：`workdoc-plan.md`, `CONTRACT.md.template`

- 代码文件
- **Python**: `snake_case.py`（例如：`user_service.py`, `db_connection.py`）
- **TypeScript/JavaScript**: `camelCase.ts` 或 `PascalCase.tsx`（例如：`userService.ts`, `UserComponent.tsx`）
- **Go**: `snake_case.go`（例如：`user_service.go`, `db_connection.go`）

- 目录命名规范

- **目录名**: `lowercase` 或 `kebab-case`（例如：`doc_agent/`, `workflow-patterns/`）
- **模块目录**: `lowercase`（例如：`modules/user/`, `modules/api_gateway/`）
- **测试目录**: `tests/` 或 `tests/<module_name>/`

- 数据库命名规范

- **表名**: `snake_case`（例如：`user_profiles`, `order_items`）
- **列名**: `snake_case`（例如：`user_id`, `created_at`, `is_active`）
- **索引名**: `idx_<table>_<columns>`（例如：`idx_users_email`）
- **约束名**: `fk_<table>_<column>` 或 `pk_<table>`（例如：`fk_orders_user_id`, `pk_users`）

- 测试命名规范

- **测试函数**: `test_<description>`（Python）或 `Test<Description>`（Go）
  - 示例：`test_user_service_creates_active_user`, `TestUserService_CreatesActiveUser`
- **测试文件**: `test_<module>.py` 或 `<module>_test.go`
  - 示例：`test_user_service.py`, `user_service_test.go`

- 注释和文档字符串规范

- 所有注释、文档字符串和日志消息必须使用配置的语言（默认：英文）
- 保持文档字符串简短且仅英文；引用设计文档而不是重复它们

- 为以下内容添加上下文：
  - 非平凡的算法或业务规则
  - 公共 API/接口
  - TODO/FIXME/HACK 标记（必须包含所有者和截止日期）

- 文档字符串格式
```python
def get_user_by_id(user_id: str) -> User:
    """
    Retrieve a user by their unique identifier.
    
    Args:
        user_id: The unique user identifier
        
    Returns:
        User object if found
        
    Raises:
        UserNotFoundError: If user does not exist
    """
```

- 2.7 命名原则

1. **清晰 > 聪明**：使用明确、描述性的名称
2. **显式 > 隐式**：避免缩写，除非是广泛接受的（如 `id`, `url`, `api`）
3. **一致性**：遵循现有模式，不要发明新的命名风格
4. **长度适中**：名称应该足够描述性，但不要过长（通常 2-4 个单词）


- 可以维护一个编写指南（含标准命名、正反例、共享 topic 的处理方式），在新目录或模块接入时引用，保证结构演进的一致性。
