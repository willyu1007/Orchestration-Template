
# 能力路由

通俗而言，能力就是封装好的功能。模板要求项目统一管理功能和调用方式，从而在AI为主要开发者的项目推进过程中，帮助AI高效应用已有工具，避免重复造轮子，并增强代码的一致性、透明度、和可控性。能力路由主要的组成部分如下：
- 能力池：项目当中所有的允许被调用的功能实现，需要通过注册才能进入项目能力池
- 能力注册表：相当于能力的注册表和身份信息，是能力的SSOT
- 路由文档：统一命名为`ABILITY.md`，只提供注册表的对象路径和使用情景概述，用来帮助AI根据任务编排需求找到能力

本质上，能力路由是AI的工具箱和工具如何组合的映射。项目通过维护一个双层能力系统，用来保持编排的可管理型。
- 低层能力：细粒度的操作，如运行脚本或调用API。通常代表原子操作，允许存在多个实现。
- 高层能力：由低层步骤组成的高级任务或工作流，会优先暴露给编排器进行规划。
  
两个层级都属于能力路由的范畴，也都处于项目的能力池中，但在能力路由中定位和使用存在一定的区别。
- 由于能力的分级是希望AI的规划尽可能保持在抽象级别上运行，而不是被底层细节淹没。所以路由文档中会优先展示并鼓励使用高层能力
- 高层/低层能力的注册表结构不用，注册脚本也不用
- 当AI需要选取能力时，高层能力主要是通过匹配情景语义和编排需求，低层能力则是匹配功能描述和编排需求
- 项目演进过程中，新的低层能力一般来自于AI开发过程中的产出，新的高层能力一般是基于AI实际需求的流程优化或整合

## 1. 概念和规则

### 1.1 路由文档

路由文档是一类统一命名的文档，其文件名称为`ABILITY.md`，在项目中起到能力路由阅读入口的作用。路由文档自身的功能，是让AI在语义层面快速查询工作域中有哪些可以使用的系统工具。

模板遵循模块化开发的思路，开发中的代码实现和管理，都是基于模块实例完成的。因而，模块实例定义了开发过程的工作边界。每个模块实例都会独立维护自身的路由文档`ABILITY.md`，也就是说，`ABILITY.md`不是全局性的，而是根据AI实际的工作域来维护的。

除功能开发外，项目还会维护一份顶层的跨模块的路由文档`ABILITY.md`。该路由通常是用于集成和联调测试场景的，即工作边界一般为实际应用场景下的端到端测试。正常情况下AI的工作域是确定的，一次AI任务编排不会阅读到两份`ABILITY.md`。

此外，路由文档会随着项目演进而演进，以求更加适配AI的实际工作需求。在项目开发过程中，如果编排对应的`ABILITY.md`无法满足开发需求，系统会要求AI记录过程内容和产出（详见后续章节）。通过CI等工具，这些内容可以帮助系统完善路由文档。

由于高层能力可以执行更加复杂的任务，同时具有更为灵活的调用方式，路由文档会优先高层能力的相关路由。AI将首先检索高层能力，填补任务编排的开发缺口。当高层能力无法完全满足编排需求或者没有可用的高层能力时，AI继续检索`ABILITY.md`中的低层能力路由，并选取可以使用的加入实施流程。

高层能力的路径检索依据
**高层能力路由结构示例：**
这里补充一个示例：{
  example
  
}

低层能力的路径检索依据
**低层能力路由结构示例：**

{
这里补充一个示例：
  example
}

### 1.2 能力池
项目需要集中维护一份全量的已注册的功能，维护的对象是各功能的实际实现。对于不同层级能力的不同类型的实现，我们可以分别进行维护。

低层能力是细粒度的、通常是特定于实现的操作，包括仓库内部脚本、外部服务调用、数据库操作等。我们按类型对低级节点进行分类，`script`、`mcp`、`api`：

**script**：项目内部实现的脚本
这里添加说明和示例（不用给出代码或结构，示例为维护的形式）

**script**：经过封装的外部服务，外部微服务或云提供者调用
这里添加说明和示例（不用给出代码或结构，示例为维护的形式）

**script**：定制需求的外部服务，外部API调用
这里添加说明和示例（不用给出代码或结构，示例为维护的形式）
  
高层能力通常是编排的工作流或代理，结合了多个步骤或决策。高级节点表示编排器将调度和管理的任务，是语义层面的能力，包含两种类型：workflow和agent。
高层能力包含两种类型：`workflow`和`agent`：

**workflow**：更偏确定的pipeline，通常按顺序调用多个脚本
这里添加说明和示例（不用给出代码或结构，示例为维护的形式）

**agent**：更偏动态驱动，可以动态调用各种低级方法，通常由AI驱动的决策过程
这里添加说明和示例（不用给出代码或结构，示例为维护的形式）

### 1.3 能力注册表
{
  本章节的内容需要细化和完善
}

路由文档直接指向路能力注册表，也就是AI在路由文档中匹配后，需要根据路径访问能力的注册表，并进一步判断功能是否和需求相符合。

注册表格式为yaml，起到明确输入/输出规范、调用情形、约束条件、使用规则等信息的作用。通过阅读能力注册表，代码大模型可以确认是否满足当前任务编排需求、掌握工具的使用方法、形成输出预期。

根据能力层级不同，高层和低层的能力注册表格式也有区别。

#### 1.3.1 低层能力注册表
低层能力的实现必须对应某个原子操作类型，从而保持其可替换性。例如，写入数据库是一个原子操作类型，但具体实现可以是脚本或云数据库提供的mcp服务。因此，低层能力注册表的主键为原子操作对象，而非具体实现。

在执行过程中，AI只需要关心“这个操作类型是否可以加入我的编排实现流程”。然后按照既定规则，调用模板提供的通用执行脚本即可。具体的实现由脚本根据配置信息和输入，在原子操作包含的实现中选取具体实现，并按照输出要求返回信息给AI。

补充完善以下信息：
{
**注册表的主要内容有**：
- 注册信息：
  - 主键
- 操作说明：
- 作用域：
- 输入：
- 输出：
- 关联实现：（AI不用阅读）
  - 实现A：文档路径
  - 实现B：文档路径
  
示例：

**实现文档**：
- 注册信息
- 实现方式    # script / mcp / api
- 归属操作
- 调用说明
- 约束条件
- 默认参数
- 覆盖规则
- 实现地址：例如脚本 / mcp 等
- tags

示例：


**配置信息**：
- 操作主键：
  - 当前默认的实现方式
  - 当前允许使用的实现方式
  - 当前配置参数（例如mcp_server、mcp_tool、endpoints、ssh_key、prompts ...）
  - 可选配置参数
  - 路由文档地址：       # 所有包含该操作的`ABILITY.md`文档路径
  - matcher:           # 关联的用于命中匹配
  - guardrail:         # 关联的护栏机制

示例：

}

#### 1.3.2 高层能力注册表

高层能力对应的是某个抽象的功能需求，以最大程度的适配AI编排。高层能力是多种原子操作类型的调用组合，所以往往不需要具体的实现，其实现主要内容是：串联起一个更加复杂的任务（可能是线性的，也可能是动态的），并在过程中根据输入、约束、配置等，调用正确的低层能力（原子操作类型包含多个实现）。

和低层能力不同，高层能力的主键为能力本身（而非操作），所以一个注册表也不会关联多个实现。在执行过程中，AI需要根据注册表信息判断“我是否可以应用这个能力完成部分开发需求”。然后按照既定规则，调用模板提供的通用执行脚本，脚本将根据输入和配置完成流程，并将输出按规范返回给AI。

补充完善以下信息：
{
**注册表的主要内容有**：
- 注册信息：
    - id：
    - 类型：      # workflow / agent 
- 能力意图说明：  # 使用情景
- 作用域（可能存在多个）
- 输入：
- 输出：


}

示例：

**配置信息**：
- 主键
  - 允许调用的原子操作集合（主键）
  - 当前配置参数（例如mcp_server、mcp_tool、endpoints、ssh_key、prompts ...）
  - 可选配置参数
  - 调用说明：
  - 实现路径：          # 具体实现存放路径
  - 路由文档地址：      # 所有包含该操作的`ABILITY.md`文档路径
  - tags
  - matcher:           # 关联的用于命中匹配
  - guardrail:         # 关联的护栏机制
  
示例

---

## 2. 使用方式和典型过程

高层能力和低层能力共同构成了项目中可用的工具池。能力路由需要解决的问题是：当AI开发者完成了开发计划或任务编排后，是不是可以直接从工具清单上找到合适的工具。

### 2.1 任务编排视角

当AI根据需求完成任务编排后，典型的应用能力路由的流程为：

1. 找到正确的能力路由文档`ABILITY.md`
2. 梳理任务编排各节点的功能开发需求，并将需求记录到上下文文档中
3. 检索路由文档中的所有高层能力，将可用的到开发工作流中
   1. 根据高层能力的应用情景描述，初步判断是否有可以加入执行工作流的能力
   2. 如果判断能力可用，根据路由文档提供的路径，阅读对应的能力注册表，进一步确认是否可用
   3. 如果确认能力可用，将高层能力加入备选清单
   4. 重复上述步骤，直至检索完所有的高层能力
   5. 从所有选择的高层能力中，选取最为适配的
   6. 再次
   7. 确认需要使用的高层能力，调用模版提供的编排执行缓存脚本，记录脚本返回的键值（对应实际工具调用）
4. 重新梳理剩余的功能开发需求，遍历检索路由文档中的低层能力
   1. 根据低层能力的功能描述，初步判断是否可以加入
5. 确认包含系统工具的开发执行工作流
6. 在需要使用工具时，通过对应的键值调用使用模版提供的工具执行脚本


明确任务需求 -> 阅读（提供的）工具清单 -> 找出所有潜在可用的工具 -> 阅读工具使用说明 -> 确定使用（一个或多个）工具 -> 依据规则使用工具 -> 记录使用过程。

AI可以检索路由文档，将系统提供的工具加入编排对应的实际执行链条/工作流中

1. 找到正确的能力路由文档（`ABILITY.md`）：该步骤相当于阅读顶层的工具清单（高层能力）
  - 如果是功能开发，目录为对应的模块实例目录
  - 如果是联调测试，目录为模块根目录下的集成子目录
2. 检索是否可以使用的高层能力
3. 匹配编排需求和能力的应用情景
4.  记录决策过程和产出
    
5.  阅读对应目录下的`ABILITY.md`：
   - 如果是功能开发，目录为对应的模块实例目录
   - 如果是联调测试，目录为模块根目录下的集成子目录
6.  查看`ABILITY.md`允许使用的高层能力以及**应用情景**说明；
   - 如发现有可以使用的高层能力，依据路由跳转至能力注册文档，检验是否要求、输入、输出等是否满足条件。如满足条件直接调用，如不满足退回`ABILITY.md`继续查询（高层能力有`maturity`字段，优先调用字段为`stable`的能力）
   - 如没有可以使用的高层能力，进入步骤三
7.  检索`ABILITY.md`包含的低层能力以及**功能描述**，决定是否调用
   - 如由可以调用的
8.  将选择能力的决策过程记录到工作上下文（`workdocs/active/<task>/details.md`）中
   - 如调用了高层能力，记录调用原因、能力`name`和`maturity`，以及执行结果
   - 如调用了低层能力，记录调用原因、能力`name`、以及执行结果。 


### 2.2 能力路由视角

从能力路由的视角出发，在AI明确任务需求后，相关的文档或文件被应用的流程为：
1. AI工作域中的`ABILITY.md`被阅读，路由文档中的部分能力注册表的路径被选中
2. AI阅读被选中的能力注册表，AI根据路由信息决定是否使用能力
3. 被选中的能力被AI加入任务编排
4. AI根据工作流顺序，按照规范给定输入，并调用模版提供的能力执行脚本
5. 执行脚本根据配置信息，判断是否可以执行，如果可执行则在能力池中找到并使用工具，如果不可执行则告知AI
6. 被使用的工具按照其实现、输入、配置等信息执行，再由执行脚本将工具的结果输出告知AI

缓存脚本的使用
执行脚本的使用




AI根据提供的`ABILITY.md`文档，找到高层或低层能力，

这些作为编排器的实际可执行单元出现，而低级方法在这些高级过程内部调用。

高层能力将被优先暴露给AI，这些经过封装的业务流将简化AI的策略执行，提升输出的可预见性和规范性。



### 2.3 指向性调用

指向性调用的形式包括手动调用或给出AI明确的要求指令两种。不论哪种，按照规范调用模板提供的脚本工具即可。

补充示例：{

}

---

## 3. 注册和维护

### 3.1 能力注册

除模板自带的实现外，进入能力路由有两种主要途径：开发过程中持续集成以及手动添加。不论是哪种方式，都需要通过模板提供的注册脚手架，完成能力注册后将其整合到能力路由中。

不论是是哪个层级哪种类型的能力，进入能力路由时都需要进行注册。注册表工具和模式验证旨在缓解在复杂的引用中可能出现的错误。

补充下述信息：
{

#### 原子操作注册

#### 低层路由注册

#### 高层路由注册

#### 注册表相关目录
能力的注册信息会存入统一的文件路径，能力实现也会统一存放。

}

### 3.2 路由维护

面向工作开发的任务编排会阅读具体模块实例的`ABILITY.md`，而面向集成测试的则会阅读集成目录下的`ABILITY.md`。以上是模板建议的唯二的两个能力路由阅读入口，也是我们需要重点维护的能力路由文档。

#### 3.2.1 可持续发展

2.1章中我们介绍了任务编排和能力路由的结合方式。项目根据AI工作范围提供的封装好的工具（`ABILITY.md`中通常不会提供所有的工具，例如，联调时只会展示测试相关的工具）很可能无法完整串起实际编排的全过程，因此部分工作需要AI进行代码编写或函数封装。

模板希望从这个过程中提取和记录有效信息，帮助完善`ABILITY.md`，使其可以持续提高AI的工作效率，而不仅仅是形式化的入口。

假如AI在任务编排中需要实现功能A，我们需要记录的信息包括：
- AI想要实现功能A，这个功能起到什么作用
- AI有没有通过能力路由，找到合适的系统工具来实现功能A
  - 调用了哪个或哪几个工具
  - AI自己写了哪些脚本，这些脚本的名称是什么
- 如果AI有新增脚本，这些脚本应该被存到指定的文件夹下，并按照规范编写注释

我们会在其他文档中（<modular_mannual.md>）中给出承接上述内容的文档和路径。利用这些要求记录的内容，我们可以得到两个方面的主要信息：
- 实际功能产出，主要为新增脚本
  - 通过新增功能的描述信息，比对其和项目当前能力池中的能力，判断新功能是否被整合吸纳
  - 检查项目当前所有待开发的功能需求以及项目整体目标，判断是否可以将新功能纳入项目的能力池（新的低层能力）
- 真实开发需求，当前路由被使用的情况
  - 检查项目的全量能力池（包括高层能力和低层能力），判断是否有可以加入路由文档`ABILITY.md`的能力
  - 检查AI工作链路，比对功能需求和项目目标，判断是否可以对低层能力进行整合或再开发（形成新的高层能力，增强语义级抽象调用）

我们希望随着项目的推进，特别是当AI深度参与功能开发的场景中，能力路由体系可以通过反馈动态适应真实需求，从而真正达到设计初衷，提高AI工作效率和代码可控性。

#### 3.2.2 触发时机

**新能力注册**
每当有新的能力加入到项目整体的已注册的能力池中，不论是高层还是低层能力，我们都应该
- 遍历当前所有的模块实例开发需求以及模块实例的`ABILITY.md`，判断是否新能力是否需要被集成
- 检查当前已声明的联调和集成需求，判断新能力是否可以起到作用，如有则将新能力加入到集成路由中
- 检查联调文档中已经具备调试能力的模块和接口，判断新能力是否可以起到作用，如有则将新能力加入集成路由中

**新模块实例注册**
每当有模块实例完成注册时，或模块实例的功能发生变化时，我们应该
- 遍历项目当前的能力池，根据模块实例的功能需求、角色定位、包含的组件等，构建`ABILITY.md`文档

**定期检验**
此外，我们还可以在CI要求定期匹配当前已注册的能力池和所有模块实例的开发需求、以及是否适合联调，并更新对应的`ABILITY.md`。

**检验工具**
模板会提供检验相关的知识文档，形式为伪agent（workflow提示词）。AI可以加载该知识，并主导完成检验工作。检验过程中，AI可以灵活调用只是文档提及的脚本或工具（也是模板提供）。

{补充潜在的脚本或工具，不需要实现，只需要说明}


### 3.3 其他


#### 3.3.1 触发器

能力路由主要是通过语义匹配机制实现的，在任务编排过程中，依靠的是AI将提取编排开发需求，并根据说明判断能力可用性的准确程度。在此基础上，我们可以将触发机制融入到能力路由体系中，起到以下几个方面的作用：
- 给出路由建议
- 增加护栏机制
- 帮助维护路由信息

触发器机制有四种激活方法：
- 用户输入关键词匹配
- 调用工具前的激活
- AI调用工具后的信息缓存
- 基于缓存信息的后处理

在第一章中，我们定义了低层能力和高层能力的配置信息，都包含了`matcher`和`guardrail`两个字段，分别对应命中和护栏机制。前者通过关键词匹配激活，起到帮助AI查找工具的作用。后者则在具体工具被调用时候起作用，属于能力本身的内部机制，需要在能力的实现中体现。

补充示例：{

}


此外，我们还可以综合使用后三种激活方式，归纳AI调用工具的意图、实际调用的选择、以及新生成的文件，帮助完成路由维护的工作。

补充和完善过程：{

}

#### 3.3.2 配置信息维护

能力注册表中维护的是功能性内容，这也是AI和人类开发者关心的信息，通过调用模板提供的脚本可以使用能力池中的工具。脚本在实际执行过程中，会参考相关能力的配置信息，这些配置信息的正确性直接影响输出结果是否符合预期。

补充和完善内容：{


}

---
