
# 能力路由

本质上，能力路由是AI的工具箱和工具如何组合的映射。我们希望AI的规划尽可能保持在抽象级别上运行，而不是被底层细节淹没。项目通过维护一个双层能力系统，用来保持编排的可管理型。
- 低层能力：细粒度的操作，如运行脚本或调用API。通常代表原子操作，允许存在多个实现。
- 高层能力：由低层步骤组成的高级任务或工作流，会优先暴露给编排器进行规划。

低层能力和高层能力都需要进行注册（模板会提供能力相关的注册和修改脚手架，以保证格式的规范）。能力的注册信息会存入统一的文件路径（区分低层和高层），能力实现也会统一存放。
每个模块实例通畅会维护自身的高层能力路由，项目会额外维护一份路由作为入口，这些路由文档命名统一为`ABILITY.md`。所有的`ABILITY.md`只提供文件路径和使用情况说明。注册机制和所有的`ABILITY.md`文档共同组成了能力路由。






## 1. 概念和基础规则


对于所有的能力（不论是高层或低层），都包含两种类型的文件：说明和实现。

说明的形式为yaml文档，是能力路由暴露给任务编排/代码大模型的阅读入口，起到明确输入/输出规范、调用情形、约束条件、使用规则等信息的作用。具体的字段结构将在后续文档中给出。

实现的形式较为多样，低层能力实现形式可以为脚本、mcp调用、api调用三种形式，高层能力实现可以为workflow和agent.
低层能力是细粒度的、通常是特定于实现的操作，包括仓库内部脚本、外部服务调用、数据库操作等。我们按类型对低级节点进行分类，script、mcp、api：
- script：项目内部实现的脚本
- mcp：经过封装的外部服务，外部微服务或云提供者调用，例如云数据库的写入
- api：定制需求的外部服务，外部API调用，例如调用大模型来实现某个功能
  
高层能力通常是编排的工作流或代理，结合了多个步骤或决策。高级节点表示编排器将调度和管理的任务，是语义层面的能力，包含两种类型：workflow和agent。
高层能力包含两种类型：`workflow`和`agent`。
- workflow：更偏确定的pipeline，通常按顺序调用多个脚本
- agent：更偏动态驱动，可以动态调用各种低级方法，通常由AI驱动的决策过程




### 1.1 说明文档

{本章节的内容可能需要细化和完善}

#### script
``` yaml
- id: base.db.migrate
tier: low
kind: script       
script: scripts/db/migrate.py:main
inputs: ...
outputs: ...
tags: [db, migration]
```

#### mcp
``` yaml
- id: base.db.query
tier: low
kind: mcp
mcp_server: cloud-db
mcp_tool: query
inputs: ...
outputs: ...
tags: [db, external]
```

#### api
``` yaml
- id: base.db.call
tier: low
kind: api
endpoints: ...
ssh_key: ...
inputs: ...
outputs: ...
tags: [llm, external]
```

#### workflow
``` yaml
- id: able.db.apply_all_migrations
tier: high
kind: workflow
domain: db
intent: apply_all_migrations
steps:
    - base.db.migrate
    - base.db.check_health
depends_on:
    - base.db.migrate
    - base.db.check_health
owner: ...
maturity: candidate
```

``` yaml
- id: able.repo.maintenance_assistant
tier: high
kind: agent
domain: repo
intent: maintenance_assistant
can_call:
    - base.db.query
    - base.db.migrate
    - base.fs.read_file
    - base.mcp.*         # 某些 mcp 能力
owner: ...
maturity: experimental
```    



### 1.2 功能实现

**低层能力**
低层能力的实现必须对应某个原子操作类型，从而保持其可替换性。例如，写入数据库是一个原子操作类型，但具体实现可以是脚本或云数据库提供的mcp服务。


**高层能力**
高层能力对应的是某个抽象的功能需求，以最大程度的适配AI编排。高层能力是多种原子操作类型的调用组合，所以往往不需要具体的实现，其实现主要内容是：串联起一个更加复杂的任务（可能是线性的，也可能是动态的），并在过程中根据输入、约束、配置等，调用正确的低层能力（原子操作类型包含多个实现）。


**相关配置**


我们规定，对于低层能力的调用



### 使用方法

低级能力旨在成为可互换的构建块，

- 手动调用脚本：将直接调用具体的实现，而不是  ！！！！！！！！
- 要求大模型执行：将 ！！！！！！！！！！！！！




### 使用方法
这些作为编排器的实际可执行单元出现，而低级方法在这些高级过程内部调用。

高层能力将被优先暴露给AI，这些经过封装的业务流将简化AI的策略执行，提升输出的可预见性和规范性。


---

## 2. 使用方式和典型过程

高层能力和低层能力共同构成了项目中可用的工具池。能力路由需要解决的问题是：当人类/AI开发者完成了开发计划或任务编排后，是不是可以直接从工具清单上找到合适的工具。

### 2.1 任务编排视角

能力路由的典型应用流程为：明确任务需求 -> 阅读（提供的）工具清单 -> 找出所有潜在可用的工具 -> 阅读工具使用说明 -> 确定使用（一个或多个）工具 -> 依据规则使用工具 -> 记录使用过程。

1. 找到正确的能力路由文档（`ABILITY.md`）：该步骤相当于阅读顶层的工具清单（高层能力）
  - 如果是功能开发，目录为对应的模块实例目录
  - 如果是联调测试，目录为模块根目录下的集成子目录
2. 检索是否可以使用的高层能力
3. 匹配编排需求和能力的应用情景
4. 记录决策过程和产出

5. 阅读对应目录下的`ABILITY.md`：
   - 如果是功能开发，目录为对应的模块实例目录
   - 如果是联调测试，目录为模块根目录下的集成子目录
6. 查看`ABILITY.md`允许使用的高层能力以及**应用情景**说明；
   - 如发现有可以使用的高层能力，依据路由跳转至能力注册文档，检验是否要求、输入、输出等是否满足条件。如满足条件直接调用，如不满足退回`ABILITY.md`继续查询（高层能力有`maturity`字段，优先调用字段为`stable`的能力）
   - 如没有可以使用的高层能力，进入步骤三
7. 检索`ABILITY.md`包含的低层能力以及**功能描述**，决定是否调用
   - 如由可以调用的
8. 将选择能力的决策过程记录到工作上下文（`workdocs/active/<task>/details.md`）中
   - 如调用了高层能力，记录调用原因、能力`name`和`maturity`，以及执行结果
   - 如调用了低层能力，记录调用原因、能力`name`、以及执行结果。 


### 2.2 实际运行视角


### 2.3 指向性调用

指向性调用的形式包括手动调用或给出AI明确的要求指令两种。


高层能力的只关心可以调用哪些底层能力（主键id），具体调用哪种实现则有配置、约束、输入等决定。




在能力路由中，高层能力会优先暴露给AI（遵循规范，例如什么情况下有哪些能力可以直接用）。由于具体的功能开发通常是限定在单个模块实例内的，所以AI的任务编排一般只能访问到部分的高层能力（模块实例会维护自身的ABILITY.md文档，这是阅读入口）

只有在AI没有找到任何可用的高层能力时，才会


### 2.4 触发器




- hooks集成
  - 我们在能力条目上添加 safety_profile，以引用与该能力相关的任何触发器或防护栏 ID。例如，像 func.db.apply_all_migrations 这样的能力可以列出它与触发器 db-migration 和防护栏策略 require_approval_for_prod 相关联，总体风险级别为 high。相反，在触发器定义中，我们将包含一个 target 字段，指向相关的能力 ID。这种双向链接确保可追溯性：如果某个能力是高风险，我们可以快速找到保护它的触发器/批准，如果触发器触发，系统知道它正在保护哪个能力（或模块）。尽管触发器和防护栏将在稍后完全实现，我们现在将定义这些链接的数据模式，并在注册表中包含几个初始示例用于测试





---

## 3. 注册和维护

能力路由中的所有能力都需要通过脚手架进行注册，但高层能力和低层能力的注册表和注册规则都是独立的。

### 3.1 能力注册

除模板自带的实现外，进入能力路由有两种主要途径：开发过程中持续集成的，以及手动添加集成的。不论是哪种方式，都需要通过模板提供的注册脚手架，完成能力注册后将其整合到能力路由中。

**低层能力的注册**
每个条目包含一个唯一 ID，格式为 base.<domain>.<action>（例如，base.db.migrate 用于数据库迁移脚本）。条目将详细说明如何执行它，例如，如果类型是 script，提供脚本路径和函数；如果类型是 mcp，提供目标服务和操作；如果类型是 api，提供外部 API 端点或密钥等。我们还列出输入/输出模式引用、所有者（负责的维护者或模块）以及用于搜索的标签。



**高层能力的注册**
每个条目有一个格式为 able.<domain>.<intent> 的 ID（例如，able.db.apply_all_migrations 用于应用迁移的工作流，或 able.repo.maintenance_assistant 用于帮助仓库维护的代理）。字段包括 tier（high）、kind（workflow 或 agent），以及详细信息，如步骤（对于工作流，要调用的低级 ID 序列，包含依赖关系）或它可以调用的能力（对于代理类型，它可能调用的低级 ID 白名单）。条目还将有一个 owner_module（链接到负责的模块）以及可能的 domain 和 intent 字段以澄清目的。



- 低层能力的典型产生过程：
  1. 1
  2. 2
  3. 3


- 面向AI的抽象高层能力进入能力路由的典型过程：
  1. 1
  2. 2
  3. 3



    - high tier 使用 "ability_registry"进行注册，low tier 使用 "method_registry"进行注册，
    - low tier 使用 "method_registry “进行注册，以业务动作为主键，同一业务动作允许多种实现。
    - low tier的命名方式使用 `base.<domain>.<action>`, 参考格式：
   
    - high tier的命名方方式： `able.<domain>.<intent>`, 参考格式：


   

不论是是哪个层级哪种类型的能力，进入能力路由时都需要进行注册。注册表工具和模式验证旨在缓解在复杂的引用网络（ID、依赖、触发器、所有者等）中可能出现的错误

我们将维护两个基于 YAML 的注册表文件来列出和定义这些节点：



### 3.2 路由文档的维护

面向工作开发的任务编排会阅读具体模块实例的`ABILITY.md`，而面向集成测试的则会阅读集成目录下的`ABILITY.md`。以上是模板建议的唯二的两个能力路由阅读入口，也是我们需要重点维护的能力路由文档。

维护这两类文档的依据主要为实际工作过程中的工具需求和新产出的工具


**新能力注册**
每当有新的能力加入到项目整体的已注册的能力池中，不论是高层还是低层能力，我们都应该
- 遍历当前所有的
- 检查当前已声明的联调和集成需求，判断新能力是否可以起到作用，如有则将新能力加入到集成路由中
- 检查联调文档中已经具备调试能力的模块和接口，判断新能力是否可以起到作用，如有则将新能力加入集成路由中

**新模块实例注册**
每当有模块实例完成注册时，或模块实例的功能发生变化时，我们应该
- 遍历项目当前的能力池，根据模块实例的需求

**定期检验**
此外，我们还可以在CI要求定期匹配当前已注册的能力池和所有模块实例的开发需求、以及是否适合联调，并更新对应的`ABILITY.md`。

**检验工具**
模板会提供检验相关的知识文档，形式为伪agent（workflow提示词）。AI可以加载该知识，并主导完成检验工作。检验过程中，AI可以灵活调用只是文档提及的脚本或工具（也是模板提供）。


### 3.3 其他

---


