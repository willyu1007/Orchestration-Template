
# 知识路由
为了减少AI在检索文档的不确定性，提高获取知识的效率和密度。我们构建了多级文档路由系统，旨在提高任务规划的效率和可靠性，给予AI明确的指导至相关信息。知识路由的两个主要目标有两个：
- 将适当的知识告知代码大模型：给AI的知识既要准确，同时也要精简。
- 路径引导符合大模型的工作模式：要发挥AI的任务编排体系的灵活性。

为达成上述两个目标，文档路由采用三层结构：顶层路由（scope） → 主题路由（topic） → 具体文档（docs）。对于每个组合，路由条目将指定目标文档，即AI应在该情况下加载的实际文档链接。这类似于图书馆的目录表索引：告诉AI应该查阅图书馆的哪个部分找哪些书以获取所需知识。我们将路由条目和目标文档视为两类文档：`路由文档`和`知识文档`，前者通过自然语义的逐层匹配帮助AI高效检索，后者则包含了上下文的具体内容。

## 1. 基本规则
知识路由是面向AI编排系统的，我们对AI任务编排的阶段进行划分:
- `understand`：理解问题 / 背景 / 概念
- `plan`：拆解任务 / 设计步骤 / 规划方案
- `act`：具体执行，通常为写代码、改配置、跑脚本等
- `review`：检查 / 评审 / 总结 / 回顾

我们对几个关键术语做进一步说明：
- 作用域（scope）：轻量级AI检索的入口，相当于总索引，让AI可以按需阅读子索引
- 主题（topic）：简短标签，用于将若干相关文档聚合在一起
- 路由（route）：对某一类主题下的“使用场景”做自然语言描述；可以指向若干个相关文档（related_docs）
- 文档（related_docs）：包含文档**相对路径**`path`（必填）、用途/角色等自然语言说明`description`（必填）、以及适用的编排阶段`stage`（选填）

由于路由文档和知识文档承担的职责完全不同，下面我们来分开定义两类文档的规范。
### 1.1 路由文档
- 命名规范：路由文档的文档名称必须为`ROUTING.md`
- 入口路由：作为AI查询知识文档的入口，包含精简的scope/topic顶层索引，并给出每个topic对应的路由文件在哪里和大概是干什么的。形式示例：
```yaml
route_indexes:
  - scope: execution.quality_gates
    topic: pre_commit_checks
    summary: 与 pre-commit 检查、质量门相关的所有文档路由。   当你需要理解或处理 pre-commit 检查相关问题时，可以加载对应 route 文件。
    route_file: /routes/execution.quality_gates.pre_commit_checks.yaml
  - scope: frontend
    topic: bug_triage
    summary: 前端 Bug 排查相关的文档路由（从理解问题、定位、到修复与验证）。
    route_file: /routes/frontend.bug_triage.yaml
  - scope: frontend
    topic: api_design
    summary: 前端 API 设计、接口约定与相关最佳实践的路由。
    route_file: /routes/frontend.api_design.yaml
  ...
```
- 具体路由：使用`when_to_use` + `doc_usage`两层结构，每层级使用自然语言进行描述，AI可根据需求进行匹配；`stage`为可选过滤项，对应AI任务编排的阶段，若缺省则无需过滤。路由的形式示例：
```yaml
---
scope: execution.quality_gates      # 可选 front matter，给人和 AI 做校验
topic: pre_commit_checks
---
routes:
  - when_to_use: 当你处理与 “pre-commit checks” 相关的问题时（包括理解概念、执行前确认规则等），使用此route。
    related_docs:
      - path: /quality/policies/global1.md
        stage: [understand, act]
        doc_usage: 主文档（alignment，优先阅读）。用于建立对质量门和 pre-commit checks 的整体认知，解释它们在本项目开发流程中的位置和目标。
      - path: /quality/policies/global2.md
        stage: [understand]
        doc_usage: 补充参考文档（alignment，可选）。包含更细粒度的组织级质量策略与规范，通常在你需要更严格或更详细的标准时再阅读。

  - when_to_use: 当你已经理解质量门的概念，准备在本地实际运行 pre-commit 检查（如make dev_check）时，使用此 route。
    related_docs: ...
```

### 1.2 知识文档
- 命名规范：无强制命名要求，仅需要满足模板统一的文档命名规范
- 常见的知识文档类型：除按照面向AI的文档元数据填写规范外，知识文档的`doc_type`取值范围如下：skill、 workflow 、 example、 或alignment
  - `skill`：特定领域技巧
  - `workflow`：辅助任务编排
  - `example`：提示或示例
  - `alignment`：对齐思路或目标

- 内容规范：除了要易于AI阅读外，文档内容还需要满足渐进式原则，即如果内容可以被明确区分，选用下列两种做法精简所需加载的上下文：
  1. 将文档拆分成多个文档，分别提供前置元数据；该做法需要重新注册文档，以确保路由正常
  2. 将内容分为多个章节，并在文档开头提供明确的段落索引；

### 1.3 其他文档

知识路由仅需要包含上述两种类型的文档，其他任何文档都不应该被包含在知识路由中。我们对不属于知识路由的典型文档类型进行梳理：
- 能力路由文档：这类文档统一命名为`ABILITY.md`，用于帮助AI找到合适的工具；详见<ability_routing.md>文档
- 策略和规则文档：这类文档是面向`AGENTS.md`的，用于规范AI的运行策略；详见<instruction_ai.md>文档
- 上下文相关文档：这类文档用于记录AI的思考过程和工作成果，其维护职责和文档使用都归属于模块实例；详见<modulate.md>中的相关内容
- 格式规范文档：这类文档并不会直接提供任务编排所需知识，但可能会提供执行所需信息（例如写入操作）。理想情况下，规范格式的相关操作应被包装成能力，AI可以直接调用能力完成写入/获取正确格式。
- 面向人类的文档：除特殊情况外，这类文档的内容不应该被AI阅读

---

## 2. 检索过程

### 2.1 逻辑示意
项目中的所有文档都需要按照规范填写前置元数据。在知识检索过程中，AI会按照策略规范，检查元数据内容以确保路由链路的准确，并必读需求加载知识上下文。
当AI接到用户的需求时，使用知识路由的典型策略如下：

1. AI判断当前所处阶段、大致的scope
2. 根据scope找到对应的route文件
3. 遍历routes，基于任务编排需求与summary做语义匹配
4. 选出最相关的一条或多条route
5. 从related_docs中选择符合当前编排阶段的文档
6. 通过description字段进行判断：哪些必读的主文档，哪些是补充或可选的文档，哪些是示例或few-shot使用
7. 访问path对应的文档，根据文档的front matter进一步校验和过滤
8. 加载符合需求的文档内容

### 2.2 文档位置
模板鼓励遵循模块化开发的思想，实际开发过程中，任务编排的作用对象为模块实例。

- 在根目录的`.content`目录下，按照文档的`scope`和`doc_type`新增目录，例如<root/.content/frontend/skills>
- 将具体的知识文档按照作用域和文档类型放到对应的目录下 
- 每个模块实例的根目录（<root/modules/{modules_entity}/>）维护一个顶层路由文档，仅维护模块实例相关的`route_indexs`
  
---
## 3. 维护和应用

### 3.1 新增/删除
- 项目开发过程中，以下情况都需要进行文档注册：
   - 添加了新的知识文档
   - 添加了新的路由文档
   - 对已有的知识文档进行了拆分
- 项目开发过程中，以下情况需要进行文档删除：
   - 需要删除某个知识/路由文档
   - 当某个知识文档的职责发生了变化（影响scope/topic/when），先删除再新增（需要重新定义路由条目）
- 不要手动完成知识文档的注册。模板将提供一个新增脚本，以确保知识路由的可用性。你可以通过以下方式调用注册脚手架：
   - 直接运行知识路由的注册脚本
   - 告诉AI你希望注册一个新的知识文档
- 不要仅仅删除文件，请调用模板提供的删除脚本，避免出现路由路径不可用的情况。你可以通过以下方式进行知识路由相关文档的删除：
   - 直接运行知识文档删除脚本
   - 告诉AI你希望删除一个知识/路由文档

### 3.2 维护

为确保知识路由持续可用、可演进，模板提供了自动化校验与人工维护相结合的机制，主要包括三部分：

1. CI 校验  
   CI 流水线会在如下几个维度定期检查：
   - 元数据完整性
     - 所有知识文档必须包含符合规范的 front matter（例如 `scope`、`doc_type` 等）。  
     - 所有路由文档必须符合本 README 中定义的结构（`route_indexes` / `routes` / `related_docs` 等）。
   - 路由一致性
     - `route_indexes` 中声明的 `route_file` 必须真实存在。  
     - `routes` 中的 `related_docs.path` 必须指向存在的知识文档。  
     - 不允许出现“孤立文档”（有知识文档但从未被任何 route 引用）或“孤立路由”（路由指向的文档已经被删除）。
   - 编排阶段覆盖性  
     - 对于声明了 `stage` 的文档，检查其阶段枚举是否在允许范围内（`understand / plan / act / review`）。  
     - 对于关键 topic，可以根据项目策略检查是否至少有一条 route 能服务核心阶段（例如 `act`）。
   一旦 CI 检测到异常，应在 MR/PR 中直接阻止合并，并给出明确的错误提示，便于开发者快速定位问题。
2. 本地校验
   为减少来回修复 CI 的成本，模板提供本地校验脚本，例如：
   - `content-routing lint`：检查当前分支的路由与知识文档结构；
   - `content-routing graph`：生成路由图谱，帮助开发者可视化“某个知识文档被哪些 route 使用”。

   开发者在本地变更知识文档或路由文档后，建议先运行本地校验再提交。

3. 随着项目演进，部分知识文档和路由可能会逐渐失真或老化，模板提供定期审视与演进：
   - 由模块 owner 定期（例如每个迭代或每月）检查：
     - 是否有 route 的 `when_to_use` 描述已经与现实不符；  
     - 是否有文档承担了过多职责，需要拆分；  
     - 是否有新的典型场景尚未被路由覆盖。
   - 对于影响面较大的调整（例如 topic 拆分 / scope 重构），优先通过 RFC 或设计评审的方式达成团队共识，再变更路由。

通过以上机制，可以尽可能保证知识路由在项目生命周期内“可查、可信、可维护”，而不会随着迭代逐渐失效。


### 3.3 触发机制

知识路由体系，特别是路由文档，主要的匹配机制是依靠AI判断语义相似度实现的。这个机制是在任务编排过程中实时完成的。考虑到需求的产生也可以通过描述来产生（不论是由用户提出需求，还是AI内化思考），我们可以设计一套触发机制，通过监听用户输入或按接口调用，输出结构化的意图。

```
{
  "scope": "execution.quality_gates",
  "intent": "ensure_code_quality_before_commit",
  "stage": "plan",
  "signals": {
    "cli_command": "make dev_check",
    "user_raw_input": "我要跑一次 pre-commit 检查"
  }
}

---






这里，我们将专注叙述过程中产出脚本的维护规范。

- 相关文档/文件：实际开发是动态变化的过程，为了将动态变化同步到能力路由体系中，模块实例维护了以下文档（通常由AI执行）
  - 路由文档**ABILITY.md**，引导AI根据需求调用能力，起到提高AI决策效率和透明度的作用。模块初始化时会生成初版的路由文档，也会根据项目开发中涉及的需求动态更新，以持续起到提效的作用。
  - 决策说明：用来记录AI大模型在任务编排过程使用能力路由的情况，记录信息：`希望调用的功能`、`实际调用的能力`、`结果是否可用`等。
  - 新增功能：如果AI找不到任何可以使用的方法
- 实例初始化：
  - 初始化不要求做任何具体的功能实现，但需要根据模块的功能需求，检索当前项目已有的低/高层功能，根据匹配关系生成第一版路由文档
  - 
- 典型流程：
  1. 检查**ABILITY.md**
  2. 根据检验结果，选择调用工具或自行开发
  3. 记录决策过程和结果
  4. **人为**更新路由、注册新功能等动态操作