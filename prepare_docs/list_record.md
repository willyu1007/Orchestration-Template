

### 清单
- root AGENTS.md
- root CAPABILITIES.md
- root ROUNTIN.md
- README.md
- doc_agent/ROUTING.md（
- doc_agent/AGENTS.md
- doc_agent/CAPABILITIES.md
- 编排配置文件（YAML/JSON）
  - doc_agent/orchestration/registry.yaml – 编排器注册表
  - doc_agent/orchestration/capabilities.yaml
  - doc_agent/orchestration/agent-graph.yaml
  - doc_agent/orchestration/doc-node-map.yaml
  - doc_agent/orchestration/agent-triggers.yaml
  - doc_agent/orchestration/trigger-map.yaml
- Policy and Guide Documents (AI-facing, lightweight docs on specific rules or procedures):
  - Security/Compliance Policies (doc_agent/policies/*.md):
  - Operational Guides and “Quickstarts” (doc_agent/quickstart/ and doc_agent/flows/)
  - Documentation Standards Spec (doc_agent/guide/documentation-spec.md or similar)
  - Script Usage Guide (scripts/operations-guide.md and sub-guides)
- Module System Documents:
  - modules/ROUTING.md
  - Module Type Contracts (modules/<type>/TYPE_CONTRACT.md)
  - Module Instance Documentation (within each modules/<instance>/doc/ directory)
    - modules/<instance>/doc/ROUTING.md 
    - modules/<instance>/doc/AGENTS.md – Module Agent Policy
    - modules/<instance>/doc/CAPABILITIES.md 
    - modules/<instance>/doc/CONTRACT.md
    - Guides/Runbooks/Specs (module-specific)
      - Module Quickstart Guide
      - Runbook/Operations Guide:
      - Module Design Spec / Guide
      - Changelog (module-specific)
      - Known Issues / Lessons Learned
    - All module doc files will have full front matter specifying audience, purpose, doc_role (e.g. guide, spec, runbook, etc.)
  - modules/registry.yaml 
    - id: a unique identifier (e.g. <type>.<instance> name),
    -	type_path and instance_path: directory paths,
    -	route_refs: pointers to the module’s key docs (quickstart or README links, etc.),
    -	graph_bindings: how this module’s agent is connected in the global graph (e.g. which parent node it attaches to),
    -	capability_refs: links to any capabilities provided,
    -	requires / provides: dependency metadata (which other modules or global services it relies on or offers to),
    -	related_modules: siblings or alternatives,
    -	ownership, status (active/deprecated), doc_set completeness, last_verified_at, etc.
    This registry is updated whenever modules are added/removed or changed, and serves as the basis for syncing the orchestrator’s view of modules
  - doc_agent/orchestration/module-registry.yaml
- AI Workdocs and Logs
  - Global Workdocs (ai/workdocs/active/…) 
    - plan.md
    - context.md 
    - tasks.md 
    - context/ subdocs
    - These workdocs are maintained by the AI (with human oversight when needed) to recover context and ensure continuity between sessions.
  - Module Workdocs (modules/<instance>/workdocs/active/…)
  - handoff-history.md – A global handoff log that records important transfer points, such as approvals, phase completions, or when development is handed over between AI and humans.
  - Maintenance Reports (ai/maintenance_reports/*.md)
    - route-health.md 
    - retrospective.md
    - Evolution or progress logs 
    - These reports are primarily for maintainers to gauge system health and for the AI to plan optimizations.
- Ops/Evaluation Documents 




### 初始化功能

- 脚手架命令 (make ai_begin MODULE=<name>)
- 文档/注册表同步脚本（python scripts/module_registry_sync.py）
- 文档-图映射同步（python scripts/doc_node_map_sync.py）
- 路由检查（运行 route_lint 目标脚本 / doc_route_check.py 脚本）
- 能力索引一致性检查（make capability_index_check / 脚本）
- Orchestrator 注册表检查 (python scripts/registry_check.py)
- Agent Lint (python scripts/agent_lint.py)
- 代理图结构检查（python 脚本/agent_graph_check.py）
- 触发器映射同步（python 脚本/trigger_map_sync.py）
- 触发器一致性检查（将 trigger_check 设置为目标）
  - Runs a dry-run simulation of all triggers using trigger_runner.py
  - Possibly scans tasks.
  - Checks for “孤立 trigger” (orphan triggers with no policy or no matching events) and would alert if found 
  - The results (trigger simulation outcomes, orphan check) are logged to route-health.md and any issues need to be fixed or documented.
- 触发执行脚本（python scripts/trigger_runner.py）
  -	It listens for or is called with specific events (like a file commit or a user command).
	-	On an event, it finds the corresponding trigger in agent-triggers.yaml, loads the associated policy section from an AGENTS.md (Trigger Handling section), and preloads any specified docs (e.g. relevant SOPs)
	-	If required_commands are specified (like running tests or lint first), it executes those (possibly via PreToolUse hook)
	-	It then invokes the target agent or tool (e.g. calls the entrypoint of the capability specified).
	-	After execution, in the PostToolUse phase, it logs the output and any files changed to the context logs (context.md#Automation and context/active-files.md)
	-	In dry-run mode, it would simulate these steps without making changes, to validate that the flow is set up correctly
	-	This tool is essential for automating responses to triggers (like auto-running DB migrations check when a new migration file is added, etc.)
- Guardrail Execution Script (python scripts/guardrail_runner.py):
  - On a critical event (e.g. code about to connect to prod DB, or a PR hits a blocked trigger), this is called to handle the approval sequence ￼ ￼.
	-	It loads the relevant guardrail policy from AGENTS.md (or Trigger Handling for that trigger) ￼, ensures required_commands (like extra lint or safety checks) are executed and passed ￼.
	-	It then helps prepare the approval bundle: gathering diff, test results, risk assessment into the context.md#Approvals section ￼ ￼ for the human approver to review.
	-	It waits or signals for approval input (this may be out-of-band from AI, but the process is documented).
	-	If approved, it logs the decision (with rationale, rollback plan) in context and plan docs ￼ ￼, updates tasks (marks Guardrail: task as completed) ￼, and allows the originally blocked action to proceed.
	-	If rejected or requiring rollback, it ensures the rollback script (defined either in policy or as per approver notes) is executed and logs the outcome ￼.
	-	Dry-run (--dry-run all) mode will simulate the above for all defined guardrail triggers to ensure the process can complete automatically (i.e., all required commands exist and pass, all references are correct) ￼.
	-	This function is crucial to maintain a closed-loop approval mechanism and is tightly integrated with the AI’s workflow (the AI must pause and wait for approval where required, then read the approver’s decision from the context to continue).
- Context Usage Tracker (python scripts/context_usage_tracker.py):
  - Trigger hit rates (how often each trigger fired over time, how often guardrails were invoked, etc.) ￼.
	-	Average execution times per agent or tool, failure rates, etc.
	-	These stats are then written to ai/maintenance_reports/route-health.md for analysis ￼.
	-	This helps identify hotspots or inefficiencies in the orchestration, e.g. if a particular path is very slow or a trigger is firing too frequently.
- AI Chain Optimizer (python scripts/ai_chain_optimizer.py)
  - E.g., if it finds an 80% hit rate on one path, it might suggest making that path more direct (less hops).
	- Or if certain nodes often fail and fallback, propose improvements or splitting/merging nodes.
	- It would write recommendations to route-health.md or a similar report.
- Schema/Contract Validators：
  - Database Schema Linter (python scripts/db_lint.py and make db_lint): 
	-	Migration Check (make migrate_check / part of db agent tools):
	-	Rollback Check (make rollback_check):
	-	These DB-related commands are likely integrated with the Data & Schema agent and listed in its tools_allowed in registry (e.g., make db_lint, make migrate_check, etc.) .
	-	API Contract Checker (python scripts/type_contract_check.py and make contract_compat_check): 
- Continuous Integration (CI) Composite Commands:
  - make dev_check.
	-	make registry_gen.
	-	make guardrail_check
	-	make module_health_check
	-	Periodic Cron/CI tasks: Weekly or periodic tasks like:
    - Running make trigger_check and make guardrail_check to produce updated telemetry.
  	- Exporting snapshots of trigger-map.yaml to check for consistency manually ￼.
	  - Checking for any “孤立” (orphaned) docs or nodes not covered by any route (perhaps part of route lint already).
- Config Lookup Utility (python scripts/config_lookup.py and make config_show)
- Visualization and Reporting Tools
  - The guide mentions a make trigger_visualizer to output a diagram of the agent graph or trigger map. 
	-	Similarly, after all setup, generating an Agent Index or summary (maybe a Markdown table of agents and their roles) could be useful, though not explicitly mentioned, it could be derived from registry.yaml for documentation.
	-	If needed, a Telemetry Dashboard script could compile the route-health metrics into charts or more digestible reports, but that may be beyond initial scope and left for future.
